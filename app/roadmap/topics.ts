import { Brain, Globe, Lock, LucideIcon } from "lucide-react";

export type Step = {
  title: string;
  description: string;
  details?: string;
  resource?: string;
  category?: "fundamentals" | "tools" | "frameworks" | "backend" | "security";
  estimatedTime?: string;
  bigDescription?: string;
  youtubeSrc?: string;
};

type Topic = {
  title: string;
  description: string;
  icon: LucideIcon;
  color: string;
  roadmap: Record<string, Step>;
};

export const topics: Record<string, Topic> = {
  "computer-architecture": {
    title: "კომპიუტერის არქიტექტურა და საოპერაციო სისტემები",
    description: "გაიგე როგორ მუშაობს კომპიუტერი შიგნიდან",
    icon: Brain,
    color: "bg-gray-700",
    roadmap: {
      "cpu-and-memory-architecture": {
        title: "CPU და მეხსიერება",
        description: "გაიგე კომპიუტერის ძირითადი კომპონენტები",
        details:
          "CPU, RAM, რეგისტრები, instruction cycle და cache-ის მნიშვნელობა.",
        resource: "/roadmap/computer-architecture/cpu-and-memory-architecture/",
        category: "fundamentals",
        estimatedTime: "3-5 დღე",
        youtubeSrc:
          "https://www.youtube.com/embed/dWGujFI4AYQ?si=oijqg_iSNbzBTV95",
        bigDescription:
          "ცენტრალური პროცესორი, ანუ CPU, არის კომპიუტერის ძირითადი ნაწილი, რომელიც პასუხისმგებელია ყველა გამოთვლითი ოპერაციის შესრულებაზე. ის განიხილება როგორც კომპიუტერის „ტვინი“, რადგან მის გარეშე პროგრამების ან ოპერაციული სისტემის მუშაობა წარმოუდგენელია. CPU მუშაობს საათის სიხშირით, რომელიც ზომაში აღინიშნება გიგაჰერცებში და აღნიშნავს, რამდენ ოპერაციას ასრულებს CPU ერთ წამში. მისი ძირითადი ნაწილებია არითმულ-ლოგიკური ერთეული (ALU), რომელიც ასრულებს მათემატიკურ და ლოგიკურ ოპერაციებს, და მართვის ერთეული (CU), რომელიც განსაზღვრავს, როგორ და რა თანმიმდევრობით შესრულდეს ინსტრუქციები. ასევე, CPU-ს შიგნით განთავსებულია რეგისტრები, რომლებიც მცირე მოცულობის, მაგრამ ძალიან სწრაფი მეხსიერების უჯრედებია და დროებით ინახავენ მონაცემებს და ინსტრუქციებს.\n" +
          "\n" +
          "CPU-ის მუშაობის პროცესში არსებობს მნიშვნელოვანი ცნება, სახელად ინსტრუქციის ციკლი. ის მოიცავს ინსტრუქციის წაკითხვას მეხსიერებიდან, მისი დეკოდირებას და საბოლოოდ, შესრულებას. ეს ციკლი მეორდება სწრაფად და უწყვეტად, რათა პროგრამებმა იმუშაონ სწორად და ეფექტურად.\n" +
          "\n" +
          "CPU-ის მხარდასაჭერად აუცილებელია მეხსიერების არქიტექტურა, რომელიც უზრუნველყოფს მონაცემებისა და ინსტრუქციების სწორად და დროულად მიწოდებას. მეხსიერება მრავალფენიანია: ყველაზე სწრაფია რეგისტრები, შემდეგ მოდის cache მეხსიერება, რომელიც CPU-სთან ახლოს მდებარეობს და მნიშვნელოვნად ამცირებს წვდომის დროს. შემდეგია RAM — ოპერატიული მეხსიერება, რომელიც ინახავს პროგრამებს და მონაცემებს, როცა ისინი აქტიურად გამოიყენება. RAM არასტაბილურია და კომპიუტერის გათიშვის შემდეგ მასში არსებული ინფორმაცია იშლება. არსებობს ასევე მუდმივი მეხსიერება, როგორიცაა ROM, SSD და HDD, რომლებიც გამოიყენება გრძელვადიანი შენახვისთვის.\n" +
          "\n" +
          "როდესაც პროგრამა მუშაობს, CPU რეგისტრებიდან იღებს პირველადი მონაცემებს, საჭიროების შემთხვევაში იყენებს cache-ს, შემდეგ RAM-დან კითხულობს დამატებით ინფორმაციას და მხოლოდ ბოლოს მიმართავს მუდმივ მეხსიერებას. CPU და მეხსიერება მუშაობენ ერთად, რათა შესაძლებელი გახდეს სწრაფი და ეფექტური გამოთვლითი პროცესები. მათი სწორად მუშაობა კომპიუტერის საერთო წარმადობისთვის გადამწყვეტია. CPU-ის სწრაფი წვდომა მეხსიერებაზე და მეხსიერების სწორი სტრუქტურა განსაზღვრავს, რამდენად ეფექტურად შეძლებს სისტემა მუშაობას მრავალფეროვან ამოცანებზე.",
      },
      "operating-system-architecture": {
        title: "საოპერაციო სისტემის საფუძვლები",
        description: "როგორ მართავს OS პროცესებს და რესურსებს",
        details:
          "პროცესები, თრედები, multitasking, schedulers და memory management.",
        resource:
          "/roadmap/computer-architecture/operating-system-architecture/",
        category: "fundamentals",
        estimatedTime: "3-5 დღე",
        youtubeSrc: "https://www.youtube.com/embed/PC37VdTD2fA",
        bigDescription:
          "ოპერაციული სისტემის არქიტექტურა წარმოადგენს კომპიუტერის პროგრამული უზრუნველყოფის იმ ნაწილს, რომელიც მართავს აპარატურას და უზრუნველყოფს მომხმარებელთან და პროგრამებთან კომუნიკაციას. ეს სისტემა არის შუამავალი, რომელიც უზრუნველყოფს პროგრამების მუშაობას ისე, რომ ისინი არ უნდა ფიქრობდნენ აპარატურულ დეტალებზე. ოპერაციული სისტემა პასუხისმგებელია ისეთ საკითხებზე, როგორიცაა პროცესების მართვა, მეხსიერების განაწილება, მოწყობილობებთან ურთიერთობა, ფაილების მართვა და უსაფრთხოების უზრუნველყოფა.\n" +
          "\n" +
          "ოპერაციული სისტემის არქიტექტურას ძირითადად რამდენიმე სტრუქტურული მოდელი აქვს. ერთ-ერთი ყველაზე გავრცელებულია მონოლითური არქიტექტურა, სადაც მთელი ბირთვი (kernel) წარმოადგენს ერთ დიდ პროგრამას, რომელიც პასუხისმგებელია ყველა ძირითად ფუნქციაზე. ასეთ არქიტექტურაში, ყველა სერვისი ერთ დონეზე მუშაობს და ერთმანეთთან პირდაპირი კავშირი აქვს. მიუხედავად იმისა, რომ ეს მიდგომა ეფექტურია სიჩქარის თვალსაზრისით, ის უფრო მოწყვლადია შეცდომებისა და უსაფრთხოების თვალსაზრისით.\n" +
          "\n" +
          "მიკრობლოკური არქიტექტურა განსხვავდება იმით, რომ ბირთვის ძირითადი ფუნქციები გადანაწილებულია მცირე სერვისებად, რომლებიც ერთმანეთს ეთანამშრომლებიან. ასეთ სისტემებში ბირთვი მხოლოდ კრიტიკულ ფუნქციებს ასრულებს, მაგალითად, პროცესების დაგეგმვას ან IPC-ს (interprocess communication). ასეთი მოდელი უკეთესია მოდულურობის, უსაფრთხოების და სისტემის შენარჩუნების თვალსაზრისით, თუმცა შეიძლება უფრო ნელა მუშაობდეს.\n" +
          "\n" +
          "ასევე არსებობს ფენოვანი არქიტექტურა, სადაც სისტემის ფუნქციონალი დაყოფილია ფენებად და ყოველი ფენა უმაღლესი ფენისათვის უზრუნველყოფს სერვისებს. მაგალითად, ყველაზე დაბლა მდებარეობს აპარატურასთან დაკავშირებული ფენა, შემდეგ მოდის ბირთვი, ფაილური სისტემა, და ბოლოს მომხმარებლის ინტერფეისი. ეს მოდელი ხელს უწყობს სისტემის გამარტივებულ დიზაინს და გამარტივებულ ტესტირებას.\n" +
          "\n" +
          "მარტივი მაგალითისთვის, როცა მომხმარებელი კლავიშს აჭერს, კლავიატურა აგზავნის სიგნალს აპარატურულ დონეზე. ეს სიგნალი გადაეცემა ბირთვს, რომელიც გადაამუშავებს და გადასცემს შესაბამის პროცესს, რომელიც უნდა რეაგირებდეს ამ მოქმედებაზე. საბოლოოდ, შედეგი მომხმარებელს უჩვენდება ეკრანზე. სწორედ ასე მუშაობს ოპერაციული სისტემა როგორც უხილავი მენეჯერი, რომელიც მართავს და აკონტროლებს კომპიუტერში მიმდინარე პროცესებს.\n" +
          "\n" +
          "ოპერაციული სისტემის არქიტექტურა აუცილებელია ეფექტური და უსაფრთხო კომპიუტერული მუშაობისთვის. სისტემის დიზაინი გავლენას ახდენს მის სტაბილურობაზე, გამტარუნარიანობაზე და დაცულობაზე, რის გამოც მისი სწორი არქიტექტურა მნიშვნელოვანია როგორც დეველოპერებისთვის, ისე საბოლოო მომხმარებლისთვის.\n",
      },
    },
  },
  "theory-of-computation": {
    title: "გამოთვლადობის თეორია",
    description: "გამოთვლადობის საზღვრები და ალგორითმების თეორიული საფუძვლები",
    icon: Brain,
    color: "bg-blue-800",
    roadmap: {
      "automata-and-languages": {
        title: "ავტომატები და ენა",
        description: "დაიწყე ავტომატების თეორიით",
        details:
          "Finite State Machines (FSM), Regular expressions, და ციფრული ენები.",
        resource: "/roadmap/theory-of-computation/automata-and-languages/",
        category: "fundamentals",
        estimatedTime: "2-3 დღე",
        youtubeSrc:
          "https://www.youtube.com/embed/58N2N7zJGrQ?si=kOfMPDjvUrtjnQ49",
        bigDescription:
          "ავტომატების და ენების თეორია კომპიუტერული მეცნიერების ერთ-ერთი ფუნდამენტური დარგია, რომელიც იკვლევს ფორმალურ ენებსა და მათ დამუშავების მოდელებს. ეს თეორია ეფუძნება მათემატიკურ ლოგიკას და მიზნად ისახავს იმის გააზრებას, როგორ მუშაობს გამოთვლითი პროცესი და როგორ შეიძლება მისი მოდელირება. ძირითადად, ამ სფეროში განიხილება ენის ტიპები, ავტომატები და გამოთვლის მოდელები, რომლებიც გამოიყენება ენის გადამუშავებისა და სექვენციების შესამოწმებლად.\n" +
          "\n" +
          "ყველაზე მარტივი მოდელია დამთავრებული ავტომატი, რომელიც შედგება მდგომარეობების ნაკრებისგან და გადასვლის წესებისგან. ის გამოიყენება იმის დასადგენად, მიეკუთვნება თუ არა მოცემული სიმბოლოების თანმიმდევრობა განსაზღვრულ ენას. მაგალითისთვის, თუ გვაქვს ენა რომელიც შეიცავს მხოლოდ იმ სტრინგებს, რომლებსაც ოდენად ბევრი 0-ები აქვთ, შეიძლება შეიქმნას ავტომატი, რომელიც გადაამოწმებს სტრინგში ნულების რაოდენობას და დაასრულებს დამტკიცებას სწორი მდგომარეობით.\n" +
          "\n" +
          "ფორმალური ენები შეიძლება წარმოდგენილ იქნას გრამატიკების საშუალებით, რომელთა მიხედვითაც იქმნება სხვადასხვა სტრინგები. ყველაზე ცნობილი გრამატიკული კლასიფიკაციაა ჩომსკის იერარქია, რომელიც ენებს ყოფს ოთხ კატეგორიად: რეგულარული, კონტექსტის თავისუფალი, კონტექსტზე დამოკიდებული და აღწერადი ენები. რეგულარული ენები ყველაზე მარტივია და მათი დამუშავება შესაძლებელია დამთავრებული ავტომატით, ხოლო კონტექსტის თავისუფალი ენებისთვის საჭიროა ბიძგიანი ავტომატები.\n" +
          "\n" +
          "ბიძგიანი ავტომატი იმით განსხვავდება დამთავრებული ავტომატისგან, რომ მას აქვს სტეკი, რაც აძლევს შესაძლებლობას დაიმახსოვროს დამატებითი ინფორმაცია და დაამუშაოს ისეთი სტრინგები, როგორიცაა ბალანსირებული ფრჩხილები. უფრო ძლიერი მოდელია ტიურნგის მანქანა, რომელიც შეუძლია ნებისმიერი გამოთვლადი პრობლემის გადაჭრა და წარმოადგენს თანამედროვე კომპიუტერის თეორიულ მოდელს.\n" +
          "\n" +
          "ამ თეორიების პრაქტიკული მნიშვნელობა დიდია პროგრამირების ენების დიზაინში, კომპილატორების აგებაში და ტექსტური მონაცემების დამუშავებაში. ავტომატებისა და ენების თეორია ასევე საფუძველს ქმნის ფორმალური მეთოდების გამოყენებისთვის პროგრამული უზრუნველყოფის ვალიდაციისა და ვერიფიკაციის პროცესებში. ამის ცოდნა ეხმარება დეველოპერებს უკეთ გაიგონ როგორ მუშაობს პროგრამების სინტაქსური ანალიზი და ენის პარსინგი.",
      },
      "turing-machines-and-computability": {
        title: "გამოთვლადობა და Turing მანქანები",
        description: "შესაძლებელია თუ არა ამ ამოცანის ამოხსნა?",
        details: "Turing Machines, Halting Problem და Church-Turing thesis.",
        resource:
          "/roadmap/theory-of-computation/turing-machines-and-computability/",
        category: "fundamentals",
        estimatedTime: "3-5 დღე",
        youtubeSrc: "https://www.youtube.com/embed/dNRDvLACg5Q",
        bigDescription:
          "ტიურინგის მანქანა და გამოთვლადობა წარმოადგენს კომპიუტერული მეცნიერების უმნიშვნელოვანეს საფუძვლებს, რომლებიც განმარტავენ თუ რას ნიშნავს გამოთვლა და როგორ განისაზღვრება ამ გამოთვლის საზღვრები. ტიურინგის მანქანა არის თეორიული მოდელი, რომელიც აღწერს იდეალურ კომპიუტერს და გამოიყენება იმისთვის, რომ განვსაზღვროთ, არსებობს თუ არა ალგორითმი რომელიმე კონკრეტული პრობლემის გადასაჭრელად.\n" +
          "\n" +
          "ტიურინგის მანქანა შედგება უსასრულო ლენტისა და თავაკისგან, რომელიც ამ ლენტაზე გადაადგილდება მარცხნივ ან მარჯვნივ. ლენტაზე თითოეულ უჯრაში შეიძლება ჩაწერილ იქნეს სიმბოლო, ხოლო თავაკს შეუძლია წაკითხვა, წაშლა ან ახალი სიმბოლოს ჩაწერა. მანქანის მოქმედება განისაზღვრება მდგომარეობების სიმრავლითა და გადასვლის ფუნქციით, რომელიც წყვეტს თუ როგორ უნდა მოიქცეს თავაკი მოცემულ მდგომარეობასა და წაკითხულ სიმბოლოზე დაყრდნობით.\n" +
          "\n" +
          "ტიურინგის მანქანის ერთ-ერთი მთავარი მნიშვნელობა იმაში მდგომარეობს, რომ ის გვეხმარება განვსაზღვროთ თუ რომელი ამოცანები შეიძლება გადაწყდეს ალგორითმულად და რომელი არა. მაგალითად, არსებობს ცნობილი პრობლემა სახელად გაჩერების ამოცანა (Halting Problem), რომელიც ამტკიცებს, რომ შეუძლებელია უნივერსალური ალგორითმის არსებობა, რომელიც წინასწარ განსაზღვრავს შეწყვეტს თუ არა ნებისმიერი ალგორითმი მუშაობას მოცემული შეყვანისთვის. ეს გვაჩვენებს, რომ არსებობს პრობლემები, რომლებიც თეორიულადაც კი არ გვარდება ალგორითმულად.\n" +
          "\n" +
          "გამოთვლადობის თეორია იყენებს ტიურინგის მანქანებს სხვადასხვა გამოთვლითი მოდელების შესადარებლად და კლასიფიცირებისთვის. მაგალითად, თუ დავამტკიცებთ, რომ ამოცანა გადაჭრადია ტიურინგის მანქანით, მაშინ შეგვიძლია დავასკვნათ, რომ ის ალგორითმულად ამოსახსნელია. თუმცა თუ არ არსებობს ტიურინგის მანქანა, რომელიც წყვეტს ამოცანას, მაშინ ის არაა გამოთვლადი, რაც ნიშნავს, რომ ტექნოლოგიურად შეუძლებელია მისი გადაწყვეტა რაც არ უნდა ძლიერი კომპიუტერი გვქონდეს.\n" +
          "\n" +
          'ტიურინგის მანქანებსა და გამოთვლადობას ფართო გამოყენება აქვს თეორიული კომპიუტერული მეცნიერების გარდა კიბერუსაფრთხოებაში, კრიპტოგრაფიაში, მონაცემთა დამუშავებასა და ხელოვნური ინტელექტის თეორიულ კვლევებში. ეს სფერო გვასწავლის ფუნდამენტურ საზღვრებს იმისა, რას ნიშნავს "გამოთვლა" და როგორ ვაცნობიერებთ ამ ცნებას კომპიუტერული სისტემების განვითარებისას.',
      },
    },
  },
  "software-engineering": {
    title: "პროგრამული უზრუნველყოფის ინჟინერია",
    description: "ისწავლე როგორ ავაშენოთ დიდი და სტაბილური სისტემები",
    icon: Brain,
    color: "bg-cyan-600",
    roadmap: {
      "version-control": {
        title: "ვერსიის კონტროლი",
        description: "ისწავლე Git და GitHub-ს გამოყენება",
        details:
          "ბაზისური ბრძანებები, branch-ები, pull request-ები და თანამშრომლობა.",
        resource: "/roadmap/software-engineering/version-control/",
        category: "tools",
        estimatedTime: "2-3 დღე",
        youtubeSrc: "https://www.youtube.com/embed/oFYyTZwMyAg\n",
        bigDescription:
          "ვერსიის კონტროლი არის სისტემა, რომელიც პროგრამისტებს და გუნდებს აძლევს შესაძლებლობას აკონტროლონ კოდის ცვლილებები დროთა განმავლობაში. ეს საშუალებას აძლევს მათ დაათვალიერონ პროექტის ისტორია, უკან დააბრუნონ ცვლილებები საჭიროების შემთხვევაში და ეფექტურად ითანამშრომლონ გუნდურ გარემოში. ვერსიის კონტროლის გამოყენება აუცილებელია განსაკუთრებით იმ შემთხვევაში, როდესაც ერთზე მეტი ადამიანი მუშაობს ერთსა და იმავე პროექტზე.\n" +
          "\n" +
          "ვერსიის კონტროლის ორი ძირითადი ტიპია: ცენტრალიზებული და დეცენტრალიზებული. ცენტრალიზებული სისტემაში არსებობს ცენტრალური სერვერი, სადაც ინახება კოდის ისტორია და ყველა დეველოპერი მუშაობს ამ სერვერთან. დეცენტრალიზებულ სისტემაში, როგორიცაა Git, თითოეულ დეველოპერს აქვს საკუთარი ლოკალური ასლი სრული ისტორიით, რაც ამცირებს სერვერზე დამოკიდებულებას და ზრდის მუშაობის მოქნილობას.\n" +
          "\n" +
          "Git არის ყველაზე პოპულარული ვერსიის კონტროლის სისტემა. ის საშუალებას გაძლევს შექმნა ლოკალური რეპოზიტორია, დაამატო ფაილები სტეიჯზე, გააკეთო კომიტი და შემდეგ ამ ცვლილებები ატვირთო გლობალურ სერვერზე, როგორიცაა GitHub. დეველოპერები ხშირად იყენებენ Git-ს იმისთვის, რომ შექმნან branches ანუ ფილიალები, რომლებიც წარმოადგენს პროექტის პარალელურ ვერსიებს. ეს ეხმარება გუნდს იმუშაოს სხვადასხვა ფუნქციონალზე ერთმანეთისგან დამოუკიდებლად და შემდეგ გააერთიანოს ეს ცვლილებები ძირითად ფილიალთან (მთავარ ხაზთან).\n" +
          "\n" +
          "ვერსიის კონტროლი ასევე მნიშვნელოვანია კოდის დამოწმების თვალსაზრისით. ის საშუალებას იძლევა გაანალიზდეს ვინ და როდის შეიტანა ცვლილება, რის შედეგადაც შესაძლებელია შეცდომების სწრაფად აღმოჩენა და გამოსწორება. გარდა ამისა, სისტემა აძლევს შესაძლებლობას rollback-ს, ანუ დაბრუნებას წინა სტაბილურ ვერსიაზე პრობლემის შემთხვევაში.\n" +
          "\n" +
          "ვერსიის კონტროლის გარეშე მუშაობა რისკიანია, რადგან მცირე შეცდომაც კი შეიძლება გამოიწვიოს მონაცემების დაკარგვა ან კოდის ვერ აღდგენა. ამ სისტემების დახმარებით კოდი დაცულია და თანამშრომლობა უფრო ორგანიზებული და უსაფრთხოა. ამიტომაც ვერსიის კონტროლი განიხილება როგორც პროფესიონალური პროგრამისტის ყოველდღიური ინსტრუმენტი და მისი ცოდნა აუცილებელია თანამედროვე პროგრამული განვითარების პროცესში.",
      },
      "unit-testing": {
        title: "ტესტირება და დებაგი",
        description: "როგორ ვამოწმოთ ჩვენი კოდი სწორად მუშაობს?",
        details: "Unit testing, integration testing, debugger-ების გამოყენება.",
        resource: "/roadmap/software-engineering/unit-testing/",
        category: "tools",
        estimatedTime: "2-3 დღე",
        youtubeSrc: "https://www.youtube.com/embed/Eu35xM76kKY\n",
        bigDescription:
          "ერთეულის ტესტირება წარმოადგენს პროგრამული უზრუნველყოფის ხარისხის უზრუნველყოფის პროცესს, რომლის მიზანია ცალკეული კომპონენტების ან ფუნქციების ინდივიდუალურად შემოწმება. ეს ტესტები იწერება იმისთვის, რომ დავრწმუნდეთ, კონკრეტული ნაწილი სისტემის სწორად მუშაობს როგორც მოსალოდნელია. ტესტები ავტომატიზებულია და იწერება იგივე პროგრამირების ენაზე, რა ენაზეც თავად პროგრამა, რაც ნიშნავს, რომ დეველოპერები ყოველდღიურად იყენებენ მას სამუშაო პროცესში.\n" +
          "\n" +
          "ერთეულის ტესტირება განსაკუთრებით მნიშვნელოვანია, რადგან ის ხელს უშლის შეცდომების გავრცელებას კოდში და აადვილებს შეცვლილი ფუნქციონალის შემოწმებას. როდესაც პროგრამაში ცვლილებებს შეიტან, ერთეულის ტესტები დაგეხმარება დაუყოვნებლივ აღმოაჩინო, დაარღვია თუ არა ეს ცვლილება არსებული ფუნქციონალი. ეს საშუალებას იძლევა კოდი იყოს უფრო სტაბილური და საიმედო.\n" +
          "\n" +
          "ტესტირების პროცესში გამოიყენება სპეციალური ტესტირების ფრეიმვორქები. მაგალითად, JavaScript-ის შემთხვევაში ხშირად გამოიყენება Jest ან Mocha, Python-ში pytest, ხოლო Java-ში JUnit. ამ ფრეიმვორქების საშუალებით დეველოპერი ქმნის ტესტის შემთხვევებს, რომლებიც აწარმოებენ კონკრეტულ ფუნქციას სხვადასხვა შეყვანით და ადარებენ შედეგს მოსალოდნელ მნიშვნელობასთან. თუ შედეგი ემთხვევა მოსალოდნელს, ტესტი წარმატებით ჩაითვლება. წინააღმდეგ შემთხვევაში, ტესტი ჩაიჭრება და დეველოპერს ეცოდინება, რომ რაღაც არასწორად მუშაობს.\n" +
          "\n" +
          "ერთეულის ტესტების დაწერა ზრდის კოდის კონფიდენციალობას, რადგან მათ საშუალებით უფრო გაბედულად შეიძლება კოდის შეცვლა, ოპტიმიზაცია და გაუმჯობესება. გარდა ამისა, ტესტები მოქმედებენ როგორც დოკუმენტაცია — სხვა დეველოპერს შეუძლია ტესტების მეშვეობით უკეთ გაიგოს რა უნდა აკეთებდეს კონკრეტულ ფუნქციას.\n" +
          "\n" +
          "ერთეულის ტესტირება ასევე მნიშვნელოვანია გუნდურ მუშაობაში. როდესაც რამდენიმე დეველოპერი ერთდროულად მუშაობს ერთ პროექტზე, ერთეულის ტესტები ეხმარებათ დარწმუნდნენ, რომ ერთმანეთის ცვლილებები არ ანგრევს კოდის სტრუქტურას. მიუხედავად იმისა, რომ ტესტების დაწერა მოითხოვს დროს, გრძელვადიან პერსპექტივაში ის ამცირებს შეცდომების აღმოსაჩენად დახარჯულ დროს და აუმჯობესებს მთლიან პროდუქტის ხარისხს.\n" +
          "\n",
      },
    },
  },
  hci: {
    title: "ადამიანი-კომპიუტერის ინტერაქცია",
    description: "UX დიზაინი და ინტერფეისის აგების ფსიქოლოგია",
    icon: Brain,
    color: "bg-pink-600",
    roadmap: {
      "ux-and-ui-fundamentals": {
        title: "UX/UI საფუძვლები",
        description: "შექმენი მარტივად გამოსაყენებელი ინტერფეისები",
        details: "ცნებები: Feedback, Consistency, Affordance, Accessibility.",
        resource: "/roadmap/hci/ux-and-ui-fundamentals/",
        category: "fundamentals",
        estimatedTime: "2-3 დღე",
        youtubeSrc: "https://www.youtube.com/embed/3NShLDM3TtM\n",
        bigDescription:
          "UX და UI წარმოადგენს ვებდიზაინისა და ციფრული პროდუქტის განვითარებაში ორ მნიშვნელოვან კომპონენტს, თუმცა ისინი ერთმანეთისგან განსხვავდება. UX ნიშნავს მომხმარებლის გამოცდილებას და ფოკუსირებულია იმაზე, როგორ აღიქვამს და იყენებს ადამიანი პროდუქტს. UI კი ნიშნავს მომხმარებლის ინტერფეისს და არის ის ვიზუალური ელემენტები, რასაც მომხმარებელი ეკრანზე ხედავს და რასთანაც აქვს უშუალო ინტერაქცია. ორივე ერთად ქმნის მჭიდრო კავშირს პროდუქტის ფუნქციურობასა და ვიზუალურ კომუნიკაციას შორის.\n" +
          "\n" +
          "UX დიზაინის მიზანია პროდუქტი იყოს რაც შეიძლება მარტივი, ეფექტური და სასიამოვნო გამოსაყენებლად. UX დიზაინერი იკვლევს მომხმარებელთა ქცევას, აგროვებს უკუკავშირს და ქმნის სტრუქტურას, რომელიც შეესაბამება მომხმარებლის მოლოდინებს. პროცესი ხშირად იწყება კვლევით, შემდეგ გადადის პერსონების შექმნაზე, მომხმარებლის სიუჟეტების აღწერაზე, ვაირფრეიმებზე და პროტოტიპირებაზე. საბოლოო მიზანი არის ის, რომ პროდუქტის გამოყენება იყოს ინტუიციური და არ საჭიროებდეს ზედმეტ ფიქრს ან ახსნას.\n" +
          "\n" +
          "UI დიზაინი ფოკუსირებულია ვიზუალურ ელემენტებზე, როგორიცაა ღილაკები, ფერები, ტიპოგრაფია, ხატულები და სივრცითი მოწყობა. UI დიზაინერის ამოცანაა ეს ელემენტები ისე გააერთიანოს, რომ შეიქმნას ლოგიკური და ესთეტიკურად სასიამოვნო გარემო, რომელიც ერთდროულად ემსახურება როგორც ბრენდის იმიჯს, ისე მომხმარებლის საჭიროებებს. კარგი UI უნდა იყოს თანმიმდევრული, ადვილად წაკითხვადი და ემთხვეოდეს UX-ის სტრუქტურას.\n" +
          "\n" +
          "მნიშვნელოვანია აღინიშნოს, რომ UX და UI მუშაობენ ერთად. კარგი ვიზუალური დიზაინი არ ნიშნავს კარგ UX-ს, და პირიქით, კარგად გააზრებული UX არ იმუშავებს ისე ეფექტურად, თუ ვიზუალური ნაწილი არ არის შესაბამისი. დიზაინერებმა ორივე ასპექტი უნდა გაითვალისწინონ პროდუქტის შექმნისას, რათა მიიღონ რეალურად გამოყენებადი და მიმზიდველი შედეგი.\n" +
          "\n" +
          "ციფრულ სამყაროში, სადაც კონკურენცია მაღალია, UX/UI დიზაინი ხშირად გადამწყვეტი ფაქტორია მომხმარებლის შენარჩუნებასა და კმაყოფილებაში. ამიტომაც კომპანიები აქტიურად ინვესტირებენ ამ სფეროში და UX/UI სპეციალისტებზე მოთხოვნა მუდმივად იზრდება. ის, ვინც კარგად ფლობს ამ პრინციპებს, შეუძლია შექმნას პროდუქტი, რომელიც არა მხოლოდ ლამაზია, არამედ პრაქტიკულიც და მომხმარებელზე მორგებული.",
      },
      "usability-testing": {
        title: "ტესტირება და გაუმჯობესება",
        description:
          "მომხმარებლის ფიდბექის გამოყენება დიზაინის გაუმჯობესებისთვის",
        details: "Usability testing, A/B ტესტირება და ჰეპურისტიკული შეფასება.",
        resource: "/roadmap/hci/usability-testing/",
        category: "tools",
        estimatedTime: "1-2 დღე",
        youtubeSrc: "https://www.youtube.com/embed/U9ZG19xtU9E\n",
        bigDescription:
          "გამოყენებადობის ტესტირება წარმოადგენს პროცესს, რომლის მიზანია შეამოწმოს რამდენად მარტივად და ეფექტურად შეუძლიათ მომხმარებლებს ციფრული პროდუქტის გამოყენება. ეს ტესტირება ეხმარება დეველოპერებსა და დიზაინერებს აღმოაჩინონ პრობლემები, რომლებიც შესაძლოა დაუმთავრებელი, გაუგებარი ან არასწორად ფუნქციონირებელი ელემენტების შედეგად წარმოიშვას. გამოყენებადობის ტესტირების მთავარი მიზანია მომხმარებლის ხედვით დადგენილი ხარვეზების აღმოჩენა და გამოსწორება, რათა საბოლოო პროდუქტი იყოს რაც შეიძლება მოსახერხებელი და ეფექტური.\n" +
          "\n" +
          "გამოყენებადობის ტესტირება ხშირად ტარდება პროდუქტის განვითარების სხვადასხვა ეტაპზე, დაწყებული პროტოტიპიდან და დამთავრებული უკვე მოქმედი აპლიკაციით. ტესტირება შეიძლება ჩატარდეს როგორც ლაბორატორიულ პირობებში, სპეციალისტების დაკვირვებით, ასევე დისტანციურად, ონლაინ ინსტრუმენტების საშუალებით. მონაწილეებს ეძლევათ კონკრეტული ამოცანები, მაგალითად როგორ მოიძიონ პროდუქტი, როგორ დაამატონ კალათაში ან როგორ გააგზავნონ ფორმა. მათი ქცევები და რეაქციები იტვირთება და ანალიზდება გუნდის მიერ.\n" +
          "\n" +
          "ტესტირების პროცესში განსაკუთრებული ყურადღება ექცევა ისეთ ელემენტებს, როგორიცაა: რამდენად სწრაფად და მარტივად ახერხებს მომხმარებელი ამოცანის შესრულებას, იყო თუ არა დაბნეულობა ინტერფეისის რომელიმე ნაწილში, რამდენად ინტუიციურია ნავიგაცია და აქვს თუ არა მომხმარებელს პოზიტიური გამოცდილება პროცესის დასრულებისას. ამ ინფორმაციის საფუძველზე გუნდს შეუძლია უკეთესად განსაზღვროს დიზაინის ცვლილებების საჭიროება.\n" +
          "\n" +
          "გამოყენებადობის ტესტირება მნიშვნელოვანია, რადგან ის ეხმარება კომპანიებს თავიდან აიცილონ სერიოზული პრობლემები პროდუქტის გაშვების შემდეგ. თუ მომხმარებელი ვერ გამოიყენებს პროდუქტის ძირითად ფუნქციებს მარტივად, ის შეიძლება საერთოდ დაკარგოს ინტერესი. ეფექტური ტესტირება ამცირებს შეცდომების რისკს, ზრდის მომხმარებლის კმაყოფილებას და საბოლოოდ, პროდუქტს უკეთეს პოზიციას აძლევს ბაზარზე.\n" +
          "\n" +
          "ეს პროცესი განსაკუთრებულ მნიშვნელობას იძენს UX/UI დიზაინის სფეროში, სადაც ყოველ დეტალს აქვს გავლენა მომხმარებლის გამოცდილებაზე. რაც უფრო ადრე და რეგულარულად ტარდება ტესტირება, მით უფრო მაღალია შანსი, რომ საბოლოო შედეგი იქნება მომხმარებელზე ორიენტირებული, პრაქტიკული და კონკურენტუნარიანი.",
      },
    },
  },
  "web-development": {
    title: "ვებ განვითარების გზა",
    description: "გზამკვლევი ფრონტენდის, ბექენდის ან DevOps-ის კარიერისთვის",
    icon: Globe,
    color: "bg-purple-500",
    roadmap: {
      internet: {
        // Added slug
        title: "ინტერნეტი",
        description: "გაიგე, როგორ მუშაობს ინტერნეტი (DNS, HTTP, ბრაუზერები).",
        details:
          "შეისწავლე კლიენტი-სერვერის კომუნიკაცია, რა ხდება როცა URL-ს წერთ, და ისეთი ცნებები როგორებიცაა IP, TCP, HTTP.",
        resource: "/roadmap/web-development/internet",
        category: "fundamentals",
        estimatedTime: "1-2 დღე",
        youtubeSrc: "https://www.youtube.com/embed/AEaKrq3SpW8\n",
        bigDescription:
          "ინტერნეტი არის გლობალური ქსელი, რომელიც აერთიანებს მილიონობით კომპიუტერს და საშუალებას აძლევს მათ ურთიერთობა ჰქონდეთ ერთმანეთთან. ის წარმოადგენს ინფორმაციის გაზიარების, კომუნიკაციის და მომსახურების მიწოდების მთავარ პლატფორმას თანამედროვე სამყაროში. ინტერნეტის ძირითადი იდეა ეფუძნება ქსელების ერთმანეთთან დაკავშირებას და მონაცემთა სწრაფ გადაცემას სხვადასხვა მოწყობილობას შორის.\n" +
          "\n" +
          "ინტერნეტის მუშაობის საფუძველს წარმოადგენს პროტოკოლების სისტემა, რომელთა შორის მთავარი როლი აქვს TCP/IP-ს. ეს პროტოკოლები განსაზღვრავენ მონაცემების შეფუთვის, გადაცემის და მიღების წესებს, რაც უზრუნველყოფს უსაფრთხო და სტაბილურ კომუნიკაციას. როცა ვწერთ ვებგვერდის მისამართს, ბრაუზერი აგზავნის მოთხოვნას სერვერზე, რომელსაც შესაბამისი რესურსი გააჩნია, და ამ რესურსის პასუხი უბრუნდება მომხმარებელს ვებგვერდის სახით.\n" +
          "\n" +
          "ინტერნეტის გამოყენების მთავარი მიზნებია ინფორმაციის ძიება, ელექტრონული ფოსტა, სოციალური მედია, ონლაინ ვაჭრობა, ვიდეო და მუსიკის ნაკადი, სწავლა და მუშაობა დისტანციურად. ამავდროულად, ინტერნეტი არის პლატფორმა კომუნიკაციისთვის, რაც საშუალებას აძლევს ადამიანებს დაუკავშირდნენ ერთმანეთს მთელი მსოფლიოდან.\n" +
          "\n" +
          "ინტერნეტის უსაფრთხო გამოყენება ძალიან მნიშვნელოვანია. არსებობს რისკები, როგორიცაა პირადი ინფორმაციის გაჟონვა, მავნე პროგრამული უზრუნველყოფა, ფიშინგი და კიბერშეტევები. სწორედ ამიტომ, საჭიროა ძლიერი პაროლების გამოყენება, სანდო ვებსაიტების მონახულება და სისტემური განახლებების რეგულარულად ინსტალაცია.\n" +
          "\n" +
          "ინტერნეტმა რადიკალურად შეცვალა ჩვენი ცხოვრების სტილი. მან გააუმჯობესა განათლებაზე წვდომა, დააჩქარა ბიზნეს პროცესები, გაზარდა ინფორმაციის ხელმისაწვდომობა და გააადვილა სოციალური კავშირები. თუმცა ამავე დროს, მან შექმნა ახალი გამოწვევები, როგორიცაა ინფორმაციული გადატვირთვა, ტექნოლოგიური დამოკიდებულება და მონაცემების კონფიდენციალურობის საკითხები.\n" +
          "\n" +
          "ინტერნეტის მნიშვნელობა დღითიდღე იზრდება. ის აღარ არის მხოლოდ ინფორმაციის ძიების საშუალება — ის გახდა პლატფორმა, სადაც ადამიანები ქმნიან, ურთიერთობენ, სწავლობენ და მუშაობენ. მომავლის სამყაროში ინტერნეტი კიდევ უფრო ინტეგრირებული იქნება ტექნოლოგიურ განვითარებაში და ჩვენი ყოველდღიური ცხოვრების ყველა ასპექტში.",
      },
      html: {
        // Added slug
        title: "HTML",
        description: "შეისწავლე ვებგვერდის სტრუქტურა HTML-ის გამოყენებით.",
        details:
          "მუშაობა სემანტიკურ თეგებზე, ფორმებზე, მედიის ჩასმასა და ხელმისაწვდომობაზე (ARIA).",
        resource: "/roadmap/web-development/html/",
        category: "fundamentals",
        estimatedTime: "2-3 დღე",
        youtubeSrc: "https://www.youtube.com/embed/qz0aGYrrlhU\n",
        bigDescription:
          "HTML ანუ HyperText Markup Language წარმოადგენს ვებდეველოპმენტის ერთ-ერთ ფუნდამენტურ ტექნოლოგიას. ის გამოიყენება ვებსაიტების სტრუქტურისა და შინაარსის განსაზღვრისთვის. HTML-ის დახმარებით შესაძლებელია ტექსტის, სურათების, ლინკების, სიების, ფორმების და სხვა ელემენტების ორგანიზება და ჩვენება ვებბრაუზერში. HTML არ არის პროგრამირების ენა — ის არის markup ენა, რაც ნიშნავს, რომ მისი საშუალებით ვუთითებთ თუ როგორ უნდა იყოს წარმოდგენილი ინფორმაცია, მაგრამ არ ვწერთ ლოგიკას ან ფუნქციონალს.\n" +
          "\n" +
          'HTML დოკუმენტი იწყება DOCTYPE html დარეკლამებით, რაც ბრაუზერს აცნობებს, რომ საქმე გვაქვს HTML5 ფორმატთან. შემდეგ მოდის html ტეგი, რომელიც შეიცავს მთელ შიგთავსს. ის იყოფა ორ ძირითად ნაწილად: <head> და <body>. <head> ნაწილი შეიცავს მეტამონაცემებს, როგორიცაა ვებსაიტის სათაური (<title>), კოდირების ტიპი (<meta charset="UTF-8">) და სხვა რესურსები. <body> ნაწილი კი აჩვენებს იმ შინაარსს, რომელსაც მომხმარებელი ხედავს ეკრანზე.\n' +
          "\n" +
          'HTML სტრუქტურაში იყენება სხვადასხვა ტეგი. მაგალითად, <h1> დან <h6> მდე გამოიყენება სათაურებისთვის, <p> აბზაცებისთვის, <a> ბმულებისთვის, <img> სურათებისთვის და <ul> ან <ol> სიებისთვის. თითოეულ ტეგს შეიძლება ჰქონდეს ატრიბუტები, რომლებიც განსაზღვრავს დამატებით ინფორმაციას ელემენტზე. მაგალითად, <a href="https://example.com">ლინკი</a> ქმნის ბმულს მითითებულ მისამართზე.\n' +
          "\n" +
          "HTML-ს ხშირად იყენებენ სხვა ტექნოლოგიებთან ერთად, როგორიცაა CSS სტილიზაციისთვის და JavaScript დინამიკის შესატანად. HTML-ის ცოდნა აუცილებელია ყველა ვებდეველოპერისთვის, რადგან ის წარმოადგენს იმ საძირკველს, რომელზეც შენდება ნებისმიერი ვებსაიტი ან ვებაპლიკაცია. მისი გამოყენება შესაძლებელია როგორც სტატიკური გვერდების შესაქმნელად, ასევე კომპლექსური სისტემების საწყის დონეზე.\n" +
          "\n" +
          "HTML-ის სწავლისას მნიშვნელოვანია პრაქტიკა — საკუთარი კოდის წერა და ნახვა ბრაუზერში. რაც უფრო მეტს ვწერთ და ვსწავლობთ სხვადასხვა ტეგს და მათ ურთიერთქმედებას, მით უფრო მარტივად შეგვიძლია გავითავისოთ ვებდიზაინის საფუძვლები და გადავიდეთ უფრო რთულ ტექნოლოგიებზე.",
      },
      css: {
        // Added slug
        title: "CSS",
        description: "დასტილე გვერდი CSS-ის დახმარებით.",
        details:
          "ისწავლე სელექტორები, box model, Flex/Grid, მედია ქუერიები და ცვლადები.",
        resource: "/roadmap/web-development/css/",
        category: "fundamentals",
        estimatedTime: "3-5 დღე",
        youtubeSrc: "https://www.youtube.com/embed/1PnVor36_40\n",
        bigDescription:
          "CSS ანუ Cascading Style Sheets არის ტექნოლოგია, რომელიც გამოიყენება ვებსაიტების სტილიზაციისთვის. ის საშუალებას იძლევა HTML სტრუქტურას მივანიჭოთ ვიზუალური ფორმა, მაგალითად ფერები, შრიფტები, განლაგება და ანიმაციები. HTML განსაზღვრავს ვებგვერდის შინაარსს, ხოლო CSS მის გარე იერსახეს. ორივე ერთად ქმნის სრულფასოვან და მომხმარებელზე მორგებულ ვებგვერდს.\n" +
          "\n" +
          'CSS მუშაობს სელექტორების პრინციპზე. სელექტორი მიუთითებს HTML ელემენტზე, რომლის სტილიც უნდა შეიცვალოს. მაგალითად, თუ გვინდა ყველა პარაგრაფის ტექსტი იყოს ლურჯი, ვწერთ შემდეგ კოდს: p { color: blue; }. ასევე შეგვიძლია კონკრეტულ ელემენტს მივანიჭოთ კლასის ან აიდენტის სახელწოდება HTML-ში და შემდეგ მივმართოთ მას CSS-ში. მაგალითად: div class="box"></div და CSS-ში ვწერთ .box { width: 100px; height: 100px; background-color: red; }.\n' +
          "\n" +
          "CSS-ს აქვს სამი ძირითადი ჩასმის გზა: inline სტილი, რომელიც პირდაპირ HTML ტეგში იწერება; internal სტილი, რომელიც HTML-ის style ტეგშია მოთავსებული; და external სტილი, რომელიც ცალკე .css ფაილშია ჩაწერილი და HTML დოკუმენტში link ტეგის მეშვეობით არის ჩართული. პრაქტიკაში ყველაზე ხშირად გამოიყენება external სტილები, რადგან ისინი განაპირობებენ კოდის გამჭვირვალობას და მრავალჯერადად გამოყენებას.\n" +
          "\n" +
          "CSS ასევე იძლევა თანამედროვე დიზაინის შესაძლებლობებს, როგორიცაა რეზპონსიული დიზაინი, რომელიც მორგებულია სხვადასხვა ეკრანის ზომებზე. ამისათვის გამოიყენება მედია-კითხვები (media queries), რომლებიც საშუალებას იძლევა სხვადასხვა სტილი იმოქმედოს სხვადასხვა მოწყობილობაზე. მაგალითად, ტელეფონზე ღილაკი შეიძლება იყოს დიდხელა და მრგვალი, ხოლო ლეპტოპზე — წაგრძელებული და მცირე ზომის.\n" +
          "\n" +
          "CSS-ის ცოდნა აუცილებელია, თუ გვსურს ვიზუალურად მიმზიდველი და პროფესიონალურად შესრულებული ვებსაიტების შექმნა. ის იძლევა სრულ კონტროლს ელემენტების ფერებზე, ზომებზე, პოზიციონირებაზე, ინტერპრეტაციასა და ტრანზიციებზე. რაც უფრო კარგად ვფლობთ CSS-ს, მით უფრო მოქნილად შეგვიძლია დავაპროექტოთ ჩვენთვის სასურველი ინტერფეისი.",
      },
      javascript: {
        // Added slug
        title: "JavaScript",
        description: "დამატე ლოგიკა და ინტერაქტივობა JavaScript-ით.",
        details:
          "ისწავლე ცვლადები, ციკლები, DOM მანიპულაცია, ES6+, async/await და fetch API.",
        resource: "/roadmap/web-development/javascript/",
        category: "fundamentals",
        estimatedTime: "1-2 კვირა",
        youtubeSrc: "https://www.youtube.com/embed/PkZNo7MFNFg\n",
        bigDescription:
          "JavaScript არის ერთ-ერთი ყველაზე პოპულარული და მნიშვნელოვანი პროგრამირების ენა, რომელიც გამოიყენება ვებსაიტების დინამიურობისა და ინტერქტიულობის შესაქმნელად. მისი საშუალებით შესაძლებელია მომხმარებლის ქმედებებზე რეაგირება, მონაცემების დამუშავება, ფორმების ვალიდაცია, ელემენტების შეცვლა გვერდზე და მრავალი სხვა ფუნქციონალი, რომელიც ცოცხალ ვებსაიტს ქმნის.\n" +
          "\n" +
          "JavaScript პირველად შეიქმნა ბრაუზერისთვის, რათა HTML და CSS-ის გვერდით დაემატებინა ლოგიკა და რეაქცია მომხმარებლის მოქმედებებზე. მაგალითად, თუ მომხმარებელი დააჭერს ღილაკს, JavaScript-ს შეუძლია გამოაჩინოს ფანჯარა, შეცვალოს ტექსტი ან გადარიდოს სხვა გვერდზე. თანამედროვე ვებაპლიკაციები მნიშვნელოვნად არიან დამოკიდებული JavaScript-ზე, რადგან მისი დახმარებით მუშაობს ისეთი სისტემები, როგორიცაა მენიუების გახსნა-დახურვა, სლაიდერები, ავტოკომპლიტი, ფილტრაცია და სხვ.\n" +
          "\n" +
          "JavaScript-ის ძირითადი ელემენტებია ცვლადები (let, const, var), მონაცემთა ტიპები (რიცხვი, ტექსტი, მასივი, ობიექტი), ფუნქციები, პირობები (if/else), ციკლები (for, while) და მოვლენების დამუშავება (event listeners). მაგალითად, შეგიძლიათ დაწეროთ ფუნქცია, რომელიც დააბრუნებს ორ რიცხვს ჯამს და გამოაჩენს შედეგს გვერდზე:\n" +
          "\n" +
          "javascript\n" +
          "Copy\n" +
          "Edit\n" +
          "function add(a, b) {\n" +
          "  return a + b;\n" +
          "}\n" +
          "console.log(add(2, 3));\n" +
          "JavaScript ასევე ხშირად გამოიყენება სხვა ტექნოლოგიებთან ერთად, როგორიცაა HTML და CSS. გარდა ამისა, ის გამოიყენება სერვერულ მხარესაც, Node.js-ის მეშვეობით, რაც ნიშნავს, რომ შესაძლებელია სრული ვებსისტემების შექმნა მხოლოდ JavaScript-ის გამოყენებით.\n" +
          "\n" +
          "დასაწყისისთვის მნიშვნელოვანია გაიგო ენის სინტაქსი, ლოგიკა და როგორ უკავშირდება HTML ელემენტებს. ამ ცოდნის დაგროვების შემდეგ შესაძლებელია ისეთი ბიბლიოთეკებისა და ფრეიმვორქების სწავლა, როგორებიცაა React, Vue ან Angular, რომლებიც მნიშვნელოვნად ამარტივებს მასშტაბური ვებაპლიკაციების განვითარებას.\n" +
          "\n" +
          "JavaScript-ის სწავლა გაძლევს შესაძლებლობას შექმნა მძლავრი და ინტერაქტიული ვებსაიტები. ის არის საფუძველი თანამედროვე ფრონტენდ ტექნოლოგიების და მისი ცოდნა აუცილებელია ნებისმიერი ვებდეველოპერისთვის.\n" +
          "\n",
      },
    },
  },
  "artificial-intelligence": {
    title: "ხელოვნური ინტელექტი და მანქანური სწავლა",
    description: "ისწავლე როგორ ფიქრობენ და სწავლობენ მანქანები",
    icon: Brain,
    color: "bg-indigo-600",
    roadmap: {
      "linear-algebra": {
        title: "ხაზობრივი ალგებრა",
        description: "გაიგე ვექტორები, მატრიცები და მათი ოპერაციები.",
        details:
          "ძირითადი ცნებები ნეირონულ ქსელებსა და მოდელებთან მუშაობისთვის.",
        resource: "/roadmap/artificial-intelligence/linear-algebra/",
        category: "fundamentals",
        estimatedTime: "3-5 დღე",
        youtubeSrc: "https://www.youtube.com/embed/JnTa9XtvmfI",
        bigDescription: `ხაზობრივი ალგებრა წარმოადგენს მათემატიკის ისეთ დარგს, რომელიც განიხილავს ვექტორებს, მატრიცებს, ხაზურ ტრანსფორმაციებს და მათ გამოყენებას მრავალ სფეროში. მისი ძირითადი მიზანია შეძლოს რთული სისტემების გამარტივება და რაციონალური გამოთვლები. ხაზობრივი ალგებრა საფუძვლად უდევს კომპიუტერულ გრაფიკას, მანქანურ სწავლებას, სტატისტიკას, ფიზიკას და სხვა მეცნიერებას.

ყველაფერი იწყება ვექტორებისგან — ისინი წარმოადგენს მდებარეობის, ძალის ან სხვა თვისებების რაოდენობრივ გამოხატვას მრავალგანზომილებიან სივრცეში. შემდეგ მოდის მატრიცები, რომლებიც ჰგავს ცხრილებს თავდაყირა და ფართობით, და გამოიყენება ვექტორზე ოპერაციების მისაცემად ან სისტემის მართვისთვის. მაგ., მატრიცის გამოყენებით შეიძლება განახორციელო როტაცია, მასშტაბირება ან თუნდაც მოცულობის ცვლილება.

ახალგაზრდა მოსწავლეებისთვის მნიშვნელოვანი ეტაპია ღია და დახურული სახემოძღვრების გამოყენება, როგორიცაა Gaussian elimination — მეთოდი, რომელსაც იყენებენ ხაზური სისტემების ამოსახსნელად. ესვე გვაძლევს საშუალება გავიგოთ მატრიცის რანგი, კერნელი და იმიჯი — სამი კლასი, რომლებსაც აქვთ მნიშვნელოვანი მნიშვნელობა მათემატიკურ ლოგიკასა და სივრცის სტრუქტურებში.

ხაზობრივი ტრანსფორმაციები — ეს არის ფუნქციები, რომლებიც აისახება ვექტორზე და ხსნიან ისეთი ცნებები, როგორიც არის სუბსპეისი, bazis, და ხაზურ ცვლილებებზე დამოკიდებული გეომეტრიული ცვლილებები. Base-ის კონცეფცია, ანუ სივრცის „სადავიზი“ ვექტორების გამოკლებით, გვაძლევს საშუალებას გადავიდეთ აბსტრაქტული ხაზური სივრცეების გაგებაზე და მათ იდენტიფიცირებაზე.

ეფორმალური მნიშვნელობით, ხაზობრივი ალგებრა ცნობილია თავისი ინსტრუმენტებით, მაგალითად, Eigen‑მूलრები და Eigen‑ვექტორები, რომლებიც აღწერენ მატრიცის მოქმედებასაც, როგორც უჯრედის გადატრიალებას გარკვეულ მიმართულებაზე. ეს ცნებები გამოიყენება მანქანურ სწავლებასა და მონაცემთა ანალიზში — სკლება და principal component analysis (PCA) — ზედმეტი შემობრუნებით შემცირებისათვის.

რა თქმა უნდა, ხაზობრივი ალგებრა არ არის მხოლოდ თეორიული — მას აქვს პრაქტიკული გამოყენებები. კომპიუტერულ გრაფიკაში ეს არის ტრანსფორმაციების საფუძველი, მონაცემთა მეცნიერებაში — მულტივარიტული ანალიზის გასაგებად, ხოლო მანქანურ სწავლებაში — ნეირონული ქსელების ფუნქციური პროპაგაციის განსაზღვრაზე. ცნებები, როგორიცაა gradient და Jacobian, პირდაპირ წარმოადგენენ ხაზური-ალგებრული ტოლობები და გარდაქმნებს.

ამ ფონზე, ხაზობრივი ალგებრა არის ის ეწოდება „ანალიზის ენა“ ტექნოლოგიებისთვის — თუ გსურს განასწავლო კომპიუტერულად რთული მოცემულობები, გააანალიზო მონაცემები ან შექმნა კლასიფიკაციური და რეგრესიული სისტემა, სწორედ ამ ცოდნის გარეშე შეუძლებელია წინსვლა.`,
      },
      python: {
        title: "Python",
        description: "ისწავლე Python ხელოვნური ინტელექტისთვის.",
        details: "სინტაქსი, მონაცემთა სტრუქტურები, NumPy და Pandas.",
        resource: "/roadmap/artificial-intelligence/python/",
        category: "tools",
        estimatedTime: "1-2 კვირა",
        youtubeSrc: "https://www.youtube.com/embed/eWRfhZUzrAc",
        bigDescription: `Python არის მაღალი დონის, ინტერპრეტირებული და მრავალმხრივი პროგრამირების ენა, რომელიც გამოირჩევა მარტივი სინტაქსით და მკაფიო ლოგიკით. იგი პოპულარულია თავის გააქტიურებაში როგორც დამწყებთათვის, ასევე პროფესიონალებისთვის და გამოიყენება ვებდეველოპმენტში, მონაცემთა ანალიზსა და მეცნიერებაში, სათამაშო ინდუსტრიისთვის და, განსაკუთრებით, ხელოვნურ ინტელექტსა და მანქანურ სწავლებაში.

Python-ის წყარო იღებს როგორც მარტივი სცენარებიდან — მაგალითად ფაილის გამოძახება, ტექსტური მონაცემების ანალიზი, ქსელის მოთხოვნები — ასევე უფრო რთული, სტრუქტურირებული მიდგომები მონაცემთა მეცნიერებაში და AI–ში. მას აქვს ძლიერი ბიბლიოთეკები და ფრეიმვორქები: NumPy და Pandas მონაცემთა წამოჭრით, Matplotlib და Seaborn ვიზუალიზაციისთვის, TensorFlow და PyTorch მანქანური სწავლებისთვის და Django თუ Flask ვებაპლიკაციების შესაქმნელად. ეს ეკოსისტემა საშუალებას გაძლევთ სწრაფად აყალიბდეთ სრულფასოვან პროექტებზე.

პროგრამირების დაწყებისთვის Python-ს აქვს ორიგინალური შესაძლებლობები, როგორიცაა მიზნობრივი კოდირების სტილი, ავტომატური მეხსიერების მართვა და დიდად გამოყენებადი პირდაპირი დოკუმენტაცია. პირველადი ცნებები მოიცავს ცვლადებს (int, float, str, list, dict), პირობებს (if, elif, else), ციკლებს (for, while), ფუნქციებს (def), კლასებს და ობიექტებზე დაფუძნებულ პროგრამირებას. ასევე მნიშვნელოვანია მეშვეობითი მოდულების ჩასმა (import) და პაკეტების მენეჯმენტი pip–ის გამოყენებით.

Python-ის სწავლა გრაგნილია კომპლექსურ კონცეფციებზე გადასასვლელად. ნელ-ნელა შეიძლება განავითაროთ ცოდნა დაბალზღვრადი პროექტებიდან — როგორიცაა სენსორით დროის აღნიშვნა — უფრო რთულ სისტემებზე — როგორიცაა ვებსერვერები, API‑ები და მონაცემთა გამოთვლის მოდელები. ჩართეთ ტესტირება (unittest, pytest), ლინტერი (flake8) და ვირტუალური გარემოები (venv), რათა შეინარჩუნოთ კოდი ორგანიზებული და სტაბილური.

Python-ის ერთ-ერთი უპირატესობა არის მისი კომუნიტეტი – უამრავი მაგალითი, StackOverflow და GitHub რესურსები, რაც აუმჯობესებს სასწავლო გამოცდილებას. გარდა ამისა, Python-ის გამოყენება ხელოვნური ინტელექტისთვის სასიცოცხლოა: ის ავსებს ხაზობრივ ალგებრას, სტატისტიკას და მანქანურ სწავლებას, რაც საშუალებას გვაძლევს შევქმნათ ნეირონული ქსელები, ნატურალური ენის დამუშავების სისტემები და სხვა თანამედროვე სისტემები.

Python‑ის შესწავლა იწყება კონსოლურ პროგრამებთან, შემდეგ შეჰყევით პროექტებს და დაკიდეთ IDE – როგორიცაა VS Code ან PyCharm. ოსტატის დონემდე ასვლა მოითხოვს პრაქტიკასა და რეგულარულ მუშაობას, მაგრამ Python-ის სიმარტივე და ძლიერება საშუალებას გაძლევთ სწრაფად მიაღწიოთ სასურველ შედეგებს.`,
      },
      "machine-learning": {
        title: "მანქანური სწავლების ალგორითმები",
        description:
          "გაიგე ძირითადი ალგორითმები: რეგრესია, კლასიფიკაცია და სხვ.",
        details:
          "სუპერვიზირებული და არასუპერვიზირებული სწავლა, გადაწყვეტილების ხეები, SVM, K‑means.",
        resource: "/roadmap/artificial-intelligence/machine-learning/",
        category: "frameworks",
        estimatedTime: "1-2 კვირა",
        youtubeSrc: "https://www.youtube.com/embed/i_LwzRVP7bg",
        bigDescription: `მანქანური სწავლება წარმოადგენს კომპიუტერული მეცნიერების ისეთ დარგს, რომელიც სწავლობს როგორ „სწავლის“ მანქანა მონაცემებიდან და პოულობს პრინციპებსა და კანონზომიერებებს დამოუკიდებლად. ხშირად იყოფა სუპერვიზირებულ და არასუპერვიზირებულ ტიპებად. სუპერვიზირებულ სწავლება მოითხოვს ნებაყოფლობით ეტიკეტირებულ (labels) მონაცემებს, როცა ითვლება ფუნქცია, რომელიც შეფასებულ მონაცემებზე ყველაზე სწორი პროგნოზს გვაძლევს. არასუპერვიზირებული სწავლების დროს სისტემა მუშაობს ეტიკეტების გარეშე და ცდილობს იპოვოს მონაცემთა ქვეპატერნები, კლასტერები და ანომალიები.

ალგორითმებმა, როგორიცაა ლინეარული და ლოჯისტიკური რეგრესია, მუშაობს ძალიან მარტივი მონაცემებზე და ეხმარება პროგნოზირებაში. მონტე‑კარლოს სიმულაციები და დამატებითი სიმირ ხეჭში (decision trees, random forest, support vector machines) გამოიყენება უფრო რთული დასკვნებისათვის. K‑means კლასტერიზაცია აერთიანებს მონაცემებს ჯგუფებად, როდესაც არ გვაქვს ეტიკეტები. ამ ალგორითმების საფუძველი არის მიმდინარობის ფუნქციები და ოპტიმიზაცია, რომელთა მიზანია შევამციროთ პროგნოზს შორის არსებული განსხვავება რეალურ და ნიშანდობლივ შედეგებს შორის.

თანამედროვე მანქანური სწავლება აგებულია ხაზოვან ალგებრაზე, სტატისტიკურ თეორიაზე და კალკულუსზე. Gradient descent არის მთავარი მეთოდი ოპტიმიზაციისთვის — ის ნაბიჯ-ნაბიჯ აქრმავს ფუნქციას მინიმუმისკენ. რეგულარიზაცია, როგორიცაა L1 და L2, გამოიყენება overfitting-ის შესამცირებლად. ასევე, მნიშვნელოვანია train/validation/test გათვლები, რათა ალგორითმი კარგად იმუშაოს როგორც ტრენინგის, ასევე უცნობი მონაცემების შემთხვევაში.

ამ სფეროში ხშირად გამოიყენება რეალური დიოტების მაგალითები და ბიბლიოთეკები: Python-ის შემთხვევაში პოპულარულია scikit‑learn მარტივი ალგორითმებისთვის, TensorFlow და PyTorch ღრმა ნეირონული ქსელებისთვის. მოდელის გამოცდის პროცესში, CSV-ებით, მონაცემთა წინასამუშაოდ, feature engineering-ით და ჰიპერპარამეტრების ოპტიმიზაციით იწერება კოდი და ტესტირდება ავტომატურად.

მანქანური სწავლების მთავარი მიზანია ჭკვიანი კომპიუტერული სისტემა შექმნა, რომელიც პროგნოზირებს ან კლასიფიცირებს ისეთ მონაცემებს, რომლებიც რთული ან მრავალმხრივი არიან. პრაქტიკაში გამოიყენება ფინანსებში, ჯანდაცვასა და IoT-ზე — მაგალითად, დაავადების პროგნოზირება, ფასის პროგნოზირება და ანომალიების გამოვლენა. დარგი სწრაფად ვითარდება და მოითხოვს მათემატიკურ, პროგრამულ და ანალიტიკურ უნარებს.

ამ ეტაპზე, რეკომენდებულია გაცნობა ალგორითმებს, შემდეგ პრაქტიკაში გადაყვანა Python-პლატფორმებზე და სასურველია — Kaggle-ის ან მსგავსი გამოწვევის შესრულება. მთავარი გზა არის რეგულარული პრაქტიკა, ალგორითმების შედარება და მონაცემთა რეალური სამყაროს პროექტები. ასე შეგეძლებათ შეიგრძნოთ მანქანური სწავლების ევოლუცია — კლასიკური მეთოდებიდან ღრმა ნეირონულ ქსელებამდე.`,
      },
      "computer-vision": {
        title: "ნეირონული ქსელები",
        description: "ისწავლე ღრმა სწავლა ნეირონული ქსელების გამოყენებით.",
        details:
          "შეისწავლე forward/backpropagation, აქტივაციის ფუნქციები, CNN და RNN სტრუქტურები.",
        resource: "/roadmap/artificial-intelligence/computer-vision/",
        category: "frameworks",
        estimatedTime: "2-3 კვირა",
        youtubeSrc: "https://www.youtube.com/embed/2w8XIskzdFw",
        bigDescription: `კომპიუტერული ხედვა (computer vision) არის კომპიუტერული მეცნიერების დარგი, რომელიც მიზნად ისახავს, რომ მანქანებმა „ინახებენ“ და გააცნობიერონ ციფრული გამოსახულებები ან ვიდეოები. ეს მოიცავს ვიზუალური ინფორმაციის ამოღებას, ანალიზს და ინტერპრეტაციას ფოტოებიდან ან ვიდეო დათვიდან. კომპიუტერული ხედვა არის დისციპლინა, რომლის მიზანია ავტომატურად გამოვიყენოთ სახე, ობიექტი, მოძრაობა ან სცენა და გადავიყვანოთ ისინი მომხმარებლისთვის გასაგებ ინფორმაციად.

კომპიუტერული ხედვის ძირითადი აპრობაციებია ობიექტების ამოცნობა (object detection), სახის იდენტიფიკაცია, სეგმენტაცია, მოძრაობის სნქრონიზაცია (motion tracking), 3D აღდგენა და ვიზუალური ძებნა. ამ ტექნოლოგიებს ფართოდ იყენებენ ავტონომიურ მანქანებში, სამედიცინო ვიზუალიზაციით, სმარტ პარკინგ სისტემებით, სურსათის ხარისხის კონტროლით და დამატებული რეალობის განვითარებით.

ტრადიციულად, კომპიუტერული ხედვა იყენებდა რიზონის და ფიზიკაზე დაფუძნებულ მათემატიკურ მიდგომებს, როგორიცაა მაგ., ტექსტურების ან კიდეების ამოცნობა. თუმცა დღეს ხელოვნურ ინტელექტთან, განსაკუთრებით ღრმა ნეირონულ ქსელებთან ერთად, გამოსახულების ამოცნობა ძალიან ეფექტურია. კონვოლუციური ნეირონული ქსელები (CNN) სპეციალურად შექმნილია სურათების პროპაგაციისთვის და სასარგებლოა ღირსეულ სიმპლებზე და ეფექტურ ვერტიკალურ არქიტექტურებზე. სამაგიეროდ, RNN და Transformers გამოიყენება ვიდეო ან სერიების გამუშავებისთვის.

მოდელები ეძებენ გამოსახულებებში მახასიათებლებს. CNN-ს მაგალითად ქმნის კონვოლუციურ ფილტრებს, რომლებიც მოძრაობენ გამოსახულებაზე და ამოიღებენ ფორმებს, ტექსტურებს ან სხვა მაღალი დონეან მახასიათებლებს. შემდეგ მიღებული მახასიათებლები გადის fully‑connected ფენებსა და აქტივაციის ფუნქციებს, როგორიცაა ReLU, softmax ან sigmoid, რათა კლასიფიცირება თუ რეგრესიის შედეგები მივიღოთ.

მოდელების ტრენინგი მიბმულია gradient descent-ზე და backpropagation-ზე — ტექნიკაზე, რომელიც პროცენტულად ამცირებს დანაკარგებს და „ასწორებს“ ქსელის ტ weights. გარდა ამისა, გამოყენებულია ტაქტიკები, როგორიცაა data augmentation, batch normalization და regularization (dropout), რათა ავიცილოთ overfitting და გავაუმჯობესოთ გენერალიზაციის უნარი უცნობ მონაცემებზე.

პოპულარული ბიბლიოთეკებია OpenCV, TensorFlow, PyTorch და Keras — პირველები ნაკლები ნეირონული, ხოლო უკანასკნელნი ღრმა სწავლისთვის. OpenCV უზრუნველყოფს გამოსახულების პრეპროცესინგის ხელსაწყოებს, ხოლო TensorFlow/PyTorch გამოიყენება ქსელების არქიტექურების შექმნაში და სასწავლებელ ციკლებში.

კომპიუტერული ხედვა არის დარგი, რომელიც ვიზუალურად იბნევა აღქმის შესაძლებლობის საზღვრზე და დღეს აუცილებელია ნებისმიერი თანამედროვე AI ინჟინერისთვის. მისი გააზრება მოითხოვს მათემატიკას, კოოდირებას და გაინტერესებას ვიზუალური სამყაროს ტექნოლოგიურ მიდგომით.`,
      },
    },
  },
  cybersecurity: {
    title: "კიბერუსაფრთხოება",
    description: "სიცოცხლეზე დამოკიდებული სისტემებისა და ქსელების დაცვა",
    icon: Lock,
    color: "bg-red-500",
    roadmap: {
      "internet-protocols-and-services": {
        title: "ქსელური საფუძვლები",
        description: "გაიგე IP, TCP, UDP, პორტები და DNS.",
        details: "ეს არის ის, თუ როგორ მოძრაობს ინფორმაცია ინტერნეტში.",
        resource: "/roadmap/cybersecurity/internet-protocols-and-services/",
        category: "fundamentals",
        estimatedTime: "2 დღე",
        youtubeSrc: "https://www.youtube.com/embed/1zVZ9cWFnCc",
        bigDescription: `ქსელური საფუძვლები არის კომპიუტერული ქსელის ფუნქციონირების ძირითადი ელემენტების ერთობლიობა, რომლებიც განსაზღვრავენ, როგორ გადაადგილდება მონაცემი ინტერნეტში. ეს მოიცავს ისეთ პროტოკოლებს და სერვისებს, როგორებიცაა IP, TCP, UDP, DNS და პორტები. მათი სწორად გაგება მნიშვნელოვანია როგორც ქსელური უსაფრთხოებისთვის, ისე სისტემების სტაბილური მუშაობისთვის.

IP ანუ Internet Protocol განსაზღვრავს, როგორ უნდა გაიგზავნოს მონაცემთა პაკეტები ერთი მოწყობილობიდან მეორეზე. თითოეული მოწყობილობას აქვს თავისი უნიკალური IP მისამართი, რომლის მეშვეობითაც პაკეტები იგზავნება დანიშნულებისკენ. თუმცა, IP პროტოკოლი არ არის საკმარისი საიმედო კომუნიკაციისთვის და სწორედ აქ ჩნდება TCP.

TCP ანუ Transmission Control Protocol პასუხისმგებელია პაკეტების სწორად გადაცემაზე. ის უზრუნველყოფს, რომ ყველა პაკეტი მივა სწორი თანმიმდევრობით და რომ არცერთი არ დაიკარგება. TCP იყენებს სპეციალურ მექანიზმებს, როგორებიცაა სამი საფეხურიანი handshake პროცესი, მონაცემის დადასტურება (ACK) და ხელახლა გაგზავნა, თუ პაკეტი დაიკარგა.

UDP ანუ User Datagram Protocol არის უფრო მარტივი და სწრაფი პროტოკოლი, რომელიც არ უზრუნველყოფს პაკეტების სრულ კონტროლს. სწორედ ამიტომ ის გამოიყენება ისეთ სიტუაციებში, სადაც სისწრაფე უფრო მნიშვნელოვანია, ვიდრე სიზუსტე — მაგალითად ვიდეოზარებში, თამაშებში ან პირდაპირი ტრანსლაციაში.

DNS ანუ Domain Name System არის ინტერნეტის „ტელეფონის წიგნი“. ის გარდაქმნის ისეთი მისამართებს, როგორებიცაა www.example.com, IP მისამართებად, რომლებსაც კომპიუტერები გამოიყენებენ კავშირში შესასვლელად. მომხმარებლებისთვის ამარტივებს ინტერნეტის გამოყენებას და ყოველდღიური ვებსერვისების ფუნქციონირებისთვის აუცილებელია.

პორტები კი წარმოადგენენ ციფრულ არხებს, რომლებსაც სხვადასხვა სერვისები იყენებენ. მაგალითად, ვებსაიტები ხშირად იყენებენ პორტ 80-ს HTTP-სთვის და 443-ს HTTPS-ისთვის. DNS იყენებს UDP პორტ 53-ს. პორტების მეშვეობით შესაძლებელია ერთ IP მისამართზე ბევრი სერვისის პარალელური ფუნქციონირება.

ამ პროტოკოლების და სერვისების სწორი გაგება აუცილებელია უსაფრთხო ქსელური გარემოს შესაქმნელად. თუ გსურს გაიგო როგორ მუშაობს რეალურად ინტერნეტი, შეგიძლია დააკვირდე რეალურ პაკეტებს Wireshark-ის დახმარებით, ან სცადო ტერმინალიდან curl, ping და dig ბრძანებების გამოყენება. ეს დაგეხმარება დაინახო როგორ რეაგირებს სისტემა მომხმარებლის თხოვნებზე და როგორ მიმდინარეობს მონაცემთა მიმოცვლა კულისებს მიღმა.`,
      },
      "cryptography-and-data-security": {
        title: "დაშიფვრა",
        description: "ისწავლე როგორ იცავს დაშიფვრა მონაცემებს.",
        details:
          "სიმეტრიული და ასიმეტრიული დაშიფვრა, SSL/TLS, ჰეშირების ალგორითმები.",
        resource: "/roadmap/cybersecurity/cryptography-and-data-security/",
        category: "security",
        estimatedTime: "2-4 დღე",
        youtubeSrc: "https://www.youtube.com/embed/JoeiLuFNBc4",
        bigDescription: `დაშიფვრა არის კრიტიკული მეთოდი, რომელსაც იყენებენ მონაცემთა უსაფრთხო გადაადგილებისთვის და შენახვისთვის. დაშიფვრის მიზანია ინფორმაციის შენახვა/გაგზავნა ისე, რომ მხოლოდ ავტორიზებულმა მხარემ შეძლოს მისი წაკითხვა. ორი მთავარი ტიპი არსებობს: სიმეტრიული და ასიმეტრიული დაშიფვრა.

სიმეტრიული დაშიფვრის შემთხვევაში დაშიფვრისა და дешიფვრისთვის გამოიყენება ერთი და იგივე გასაღები. ეს არის სწრაფი და ეფექტური კრიპტო მოდელი, რომელიც გამოიყენება, თუ ორივე მხარე გასაღების გამოყენებას შეძლებს. მაგალითად, AES (Advanced Encryption Standard) არის უმოკლესი და ფართოდ გამოყენებადი სიმეტრიული ალგორითმი.

ასიმეტრიული დაშიფვრა ეყრდნობა ორი გასაღების წყვილს – საჯარო და პირადს. საჯარო გასაღები გამოიყენება ინფორმაციის დაშიფვრაში, გამოქვეყნებულად ყველასთვის, ხოლო პირადი გასაღები მხოლოდ ერთ ადამიანს ეკუთვნის და გამოიყენება дешიფვრისთვის. მაგალითია RSA, რომელიც გამოიყენება, მაგალითად, ციფრული ხელმოწერებისთვის და TLS კავშირის დასაცავად.

ჰეშირება არის დამატებითი ტექნიკა, რომლის დახმარებით შეიძლება შემოწმდეს მონაცემების მთლიანობა. ჰეშირებით დგინდება, შეცვლილი გაქვთ თუ არა მონაცემი — ისეთ ალგორითმებს იყენებენ, როგორიცაა SHA‑256. ჰეშირებულ დადასტურებას ხშირად თან ახლავს მხარდაჭერა შემოწმების ფუნქციების ფორმატში.

დამატებით, დაშიფვრა მუშაობს უსაფრთხოების უფრო კომპლექსურ სისტემურ კონტექსტებში. SSL/TLS არის გაინტეგრირებული პროტოკოლები, რომლებიც უზრუნველყოფენ HTTPS და სხვა სერვისების დაცულ კავშირს. ისინი აწყობენ asymmetrical კენჭის გაცვლას ცუდ-კოლაბორაციულ ქსელებში, შემდეგ კი აკონტროლებენ მონაცემთა სიმეტრიულ დაშიფვრის გამოყენებით.

მაღალხარისხიანი სისტემა იყენებს „ჰიბრიდულ მოდელებს“ — პირველ ეტაპზე აქვთ asymmetrical დაშიფვრა სესიაში გასაღების გადასაცემად, შემდეგ კი აქტიურად გამოიყენება სიმეტრიული დაშიფვრა სწრაფ გადასაცემად. ასეთი მიდგომა სტანდარტულია HTTPS, SSH და სხვა დაცულ კავშირებში.

დაშიფვრა არ არის მხოლოდ ტექნიკური ნიუანსი — ეს არის კრიტიკული კომპონენტი ჩვენი დღევანდელი ციფრული ცხოვრების. ყველა ფინანსური ტრანზაქცია, კონფიდენციალური მოლაპარაკებები ან პირადი კომუნიკაცია ტარდება დაშიფრული არხების მეშვეობით. მომავლისთვის მნიშვნელოვანია გაღრმავება მოწინავე თემებზე: ციფრული სიგნატურები, key management, PKI და პოსტ‑კვანტულ კრიპტოგრაფიას. ეს ყველა ცნებები სააგენტოს კიბერუსაფრთხოების სისტემების საფუძველია.`,
      },

      firewalls: {
        title: "ფაიერვოლები",
        description: "გაიგე როგორ მუშაობს ფაიერვოლი და როგორ იცავს სისტემებს.",
        details:
          "ტრეფიკის ფილტრაცია, წვდომის წესები, ფაიერვოლის ტიპები და მაგალითები.",
        resource: "/roadmap/cybersecurity/firewalls/",
        category: "security",
        estimatedTime: "1 დღე",
        youtubeSrc: "https://www.youtube.com/embed/aNXgJ5eT0fM",
        bigDescription: `ფაიერვოლი არის კიბერუსაფრთხოების ერთ-ერთი ფუნდამენტური ელემენტი, რომელიც გამოიყენება ქსელის კონტროლისა და არასასურველი კავშირის თავიდან აცილებისთვის. მისი მიზანია განსაზღვროს, რომელი მონაცემთა პაკეტები უნდა დაიშვას ან დაბლოკოს მოწყობილობაზე ან მთელ ქსელზე. ფაიერვოლი მოქმედებს როგორც ფილტრი — იგი აფასებს პაკეტის წყაროს, დანიშნულების მისამართს, პორტს და პროტოკოლს, შემდეგ კი წყვეტს, დაშვებული უნდა იყოს თუ არა კონკრეტული კომუნიკაცია.

არსებობს ორი ძირითადი ტიპის ფაიერვოლი: ქსელური (network firewall) და ჰოსტზე დაფუძნებული (host-based firewall). ქსელური ფაიერვოლი იცავს მთელ ქსელს და ჩვეულებრივ განთავსებულია ქსელის საზღვარზე, მაგალითად, როუტერსა და ინტერნეტს შორის. ჰოსტზე დაფუძნებული ფაიერვოლი კი მუშაობს ინდივიდუალურ მოწყობილობაზე და აკონტროლებს იმ აპლიკაციებსა და კავშირებს, რომლებიც უშუალოდ იმ სისტემაზე მიმდინარეობს.

ფაიერვოლს აქვს წესების ბაზა, რომელიც განსაზღვრავს რომელ პორტზე, პროტოკოლზე ან IP მისამართზე უნდა განხორციელდეს შეზღუდვა ან დაშვება. მაგალითად, შეგვიძლია ავკრძალოთ ყველა შემომავალი კავშირი TCP პორტზე 22, რომელიც გამოიყენება SSH-თვის, თუ არ გვჭირდება დისტანციური წვდომა.

თანამედროვე ფაიერვოლები ხშირად არიან Stateful — რაც ნიშნავს, რომ ისინი აკონტროლებენ არა მხოლოდ ინდივიდუალურ პაკეტს, არამედ მთელ სესიის მდგომარეობას. მაგალითად, თუ პაკეტი არის სესიის ნაწილი, რომელიც უკვე დასაშვებია, ფაიერვოლი ავტომატურად გაატარებს მას. ზოგი ფაიერვოლი მოიცავს ასევე deep packet inspection ფუნქციებს, რაც ნიშნავს, რომ შესაძლებელია აპლიკაციის შიგთავსის ანალიზიც კი — არა მხოლოდ ზედაპირი.

ფაიერვოლები გამოიყენება როგორც სახლში, ისე საწარმოო გარემოში და მათი სწორად კონფიგურაცია არის მნიშვნელოვანი უსაფრთხოების პრაქტიკა. ბევრ შემთხვევაში გამოიყენება NAT (Network Address Translation) ფაიერვოლები, რომლებიც უზრუნველყოფენ IP მისამართების დამალვას ინტერნეტისგან და დამატებით უსაფრთხოების ფენას ქმნიან.

ფაიერვოლს შეიძლება ჰქონდეს whitelist და blacklist რეჟიმები — whitelist-ში დაშვებულია მხოლოდ კონკრეტული წყაროები, ხოლო blacklist რეჟიმში იბლოკება განსაზღვრული IP-ები ან პორტები.

დღესდღეობით, ფაიერვოლი არის კიბერუსაფრთხოების ერთ-ერთი მთავარი ბარიერი, რომელიც ხელს უშლის მავნე კოდს, ჰაკერულ შემოტევებს და მონაცემების დაკარგვას. მის გარეშე სისტემა დაუცველი რჩება და ნებისმიერ ღია პორტზე შეიძლება მოხდეს არავარაუდებელი შეტევა. ფაიერვოლის სწორად გამართვა და მისი ლოგების მონიტორინგი აუცილებელია თანამედროვე სისტემებში.`,
      },
      "threat-detection": {
        // Added slug
        title: "მუქარის აღმოჩენა",
        description: "მოიცანი მავნე ქცევები სისტემებსა და ქსელებში.",
        details:
          "IDS/IPS სისტემები, ანომალიების აღმოჩენა და ძირითადი ფორენზიკა.",
        resource: "/roadmap/cybersecurity/threat-detection/",
        category: "security",
        estimatedTime: "3-5 დღე",
        youtubeSrc: "https://www.youtube.com/embed/f5zfJmIcwfY",
        bigDescription: `მუქარის აღმოჩენა წარმოადგენს სისტემებისა და ქსელების ანალიზის სისტემას, რომელიც გადამოწმებს, იგებს თუ იწარმოება მავნე ქცევები ან შეტევები IT ინფრასტრუქტურაში. მისი მიზანია რეალურ დროში გამოავლინოს არასასურველი ან იდენტიფიცირებული აქტივობები – როგორიც არის ექსპლოიტაცია, DDoS, ანომალიები ან გაუმართავი ქცევა.

მუქარის აღმოჩენის სისტემა შეიძლება იყოფოდეს ორ ძირითად ტიპად: IDS (Intrusion Detection System) და IPS (Intrusion Prevention System). IDS აღრიცხავს პოტენციურად საფრთხის შემცველ ქმედებებს და ალარმს იძლევა, ხოლო IPS აგრესიულად იღებს ზომებს – ბლოკავს პაკეტებს ან ინიცირებულია თავდასხმიდან თავდასაცვითი მოქმედებებით.

შემდეგი მნიშვნელობა აქვს ანომალიების აღმოჩენას – სისტემები განსაზღვრავენ წინა ქცევის ნორმებს და დადგენილგან Deviations-ის (გამოცილებანი) მიხედვით აფილტრავენ ან დაამატებენ ალგორითმებს მგრძნობიარედ ოპერსიონალური შიფრებს. ამ მიდგომის გამოყენება ეხმარება გამოვავლინოთ ბრტყელი მავნე ქცევები, შინაგანი პრობლემები ან უცნობი საშიშროებები.

ლოგების ანალიზი კომპონენტის მნიშვნელოვანი ნაწილია. Firewall-ების, სერვერების, აპლიკაციების ლოგებში ჩატარცხვაა დეტალები, რომლითაც ხერხდება შეტევების ამოცნობა: როგორი იყო დრო, IP ჯანმრთელობა, სამიზნე, რაოდენობა და ტიპი. ამ მონაცემებზე დაყრდნობით ხდება შეტევაზე დროულად რეაგირება და Forensic ანალიზის მექანიზმი.

ფორენზიკა გვაქვს, როცა სისტემაში საფრთხის ნიშნები იჩენს — ნორმალიზებული მონაცემები ინარჩუნებენ ნაწილობრივ ან სრული ინფრასტუქტურის მინიჭებას და ინახება, რათა მოგვიანებით بتوان شود კონკრეტული ინციდენტის ანალიზის ან სასამართლო-კვლევის მიზნით გამოყენება.

ამ სისტემის ეფექტურობა ავსებს ხელოვნური ინტელექტით გამომუშავებულ ან ე.წ. მოწინავე Signature-Based ხერხებით. ML-ის გამოყენება შესაძლოა მანიშნებელთა განსაცვიფრებლად ან თუნდაც რეალურ დროში ავტომატური რეაგირება.

Დღეისათვის, გადაწყვეტილებები ამ სფეროში მოიცავს SIEM (Security Information and Event Management) პლატფორმებს, როგორიცაა Splunk, ELK/Elastic და QRadar. ისინი ეხმარებიან ცენტრალიზებულად აკონტროლონ სისტემური ატივი, ამუშაონ სტატისტიკა და ალგორითმები საფრთხის გამოვლენისას.

მუქარის აღმოჩენა არის კიბერუსაფრთხოების სიძლიერის ერთ-ერთი მთავარი კომპონენტი. მისი გამოყენებით კომპანიები აუმჯობესებენ რეაგირების დროს, ზღუდავენ ფინანსურ რისკებს და ავიცილებენ მონაცემთა გაჟონვას. უსაფრთხო გარემოს დაცემა მოითხოვს მონიტორინგს, ავტომატიზაციას და ქმედით ინსტრუმენტებს თავდასხმის წინააღმდეგ.`,
      },
    },
  },
  "algorithms-data-structures": {
    title: "ალგორითმები და მონაცემთა სტრუქტურები",
    description: "ისწავლე პროგრამირების ლოგიკა და ეფექტური მონაცემთა მართვა",
    icon: Globe,
    color: "bg-orange-400",
    roadmap: {
      "variables-and-types": {
        title: "ცვლადები და ტიპები",
        description:
          "გაიგე ცვლადების მნიშვნელობა და მონაცემთა ტიპების გამოყენება.",
        details:
          "ესაა პროგრამირების საფუძველი, რომელიც გამოიყენება ალგორითმების სწორად გასაგებად.",
        resource: "/roadmap/algorithms-data-structures/variables-and-types/",
        category: "fundamentals",
        estimatedTime: "1-2 დღე",
        youtubeSrc: "https://www.youtube.com/embed/yW3djfqFT8E",
        bigDescription: `ცვლადები და მონაცემთა ტიპები პროგრამირების საფუძველია. ცვლადი წარმოადგენს სახელით განსაზღვრულ კონტეინერს, რომელშიც შეიძლება შევინახოთ სხვადასხვა მნიშვნელობა და გამოვიყენოთ მოგვიანებით კოდის შესრულების პროცესში. ყველა ცვლადი გააჩნია ტიპი — ეს არის აღწერა, თუ რა სახის მონაცემი შეიძლება შეიცავდეს. პოპულარული ტიპებია ციფრები (integer, float), ტექსტი (string), ლოგიკური მნიშვნელობები (boolean) და სხვადასხვა კოლექციები (მასივი, ობიექტი).

თქვენ შეძლებთ დაწეროთ:
let age = 25 // integer ტიპი
let price = 12.99 // float ტიპი
let name = "მიხეილ" // string ტიპი
let isActive = true // boolean ტიპი

მონაცემთა ტიპები ეხმარებიან კომპიუტერს სწორად მოამუშავოს მონაცემები. მაგალითად, თუ მომხმარებელი ტოვებს ტექსტის მნიშვნელობას ციფრის მსგავსად, პროგრამა აუცილებლად გამოიწვევს შეცდომას ან არასწორ შედეგს. ტიპები გვიცავენ ამავდროულად ტიპების შეუთავსებლობისგან და ხელს უწყობენ პროგрами მიეღწიოს მოწესრიგებულ კოდამდე.

გარწმუნდით, რომ იცავთ ტიპის შესაბამისობას — ბევრი პროგრამირების ენა (მაგალითად JavaScript) იყენებს დინამიური სტატუსის სისტემა, რაც იმას ნიშნავს, რომ ტიპები ნაწილობრივ ავტომატურად იცვლებიან, ხოლო ისეთ ენებში, როგორებიცაა Java ან C#, ტიპები მკაცრად არის განსაზღვრული და შეცდომები ხშირად ერორები ხდება compile-ის ეტაპზე.

ცვლადებისა და ტიპების გამოყენების შემდეგ შეძლებთ ჩართული ფუნქციების, ციკლების და პირობების დაწერას. მაგალითად:
if (age >= 18) {
  console.log("სრულწლოვანია");
}

Python-ის მაგალითის მსგავსად:
age = 25
name = "მიხეილ"
is_active = True

Python არის დინამიურად ტიპიზებული ენა — არ არის საჭირო ტიპის წინასწარ გამოცხადება, მაგრამ მნიშვნელოვანია ვიცოდეთ, რა ჩანაწერებია და როგორ იყენებენ. ეს დაეხმარება კოდი იყოს უფრო წაკითხული და სტაბილური.

პროგრამის განვითარებასთან ერთად, დარწმუნდით, რომ იყენებთ ტიპობრივი კონვერტირებას (შეცვალოთ ტიპი int‑იდან string‑ზე და პირიქით) და შეამციროთ ტიპის შეცდომები. ეს ინფრასტრუქტურა ქმნის პროგრამირების მეტ შეთანხმებულ, ძლიერი და ნაკლებად შეცდომაების სერვისს.`,
      },
      "array-and-linked-list": {
        title: "Array და Linked List",
        description: "ისწავლე მონაცემთა ჩამონათვალის ორი ძირითადი სტრუქტურა.",
        details:
          "განსხვავებები array-სა და linked list-ს შორის, მუშაობის პრინციპები და გამოყენების შემთხვევები.",
        resource: "/roadmap/algorithms-data-structures/array-and-linked-list/",
        category: "fundamentals",
        estimatedTime: "2-3 დღე",
        youtubeSrc: "https://www.youtube.com/embed/lC-yYCOnN8Q",
        bigDescription: `Array და Linked List არიან მონაცემთა სტრუქტურები, რომლებიც გამოიყენება ელემენტების ზედიზედ შესანახად, თუმცა თითოეულ მათგანს აქვს თავისი უპირატესობანი და შეზღუდვები.

Array არის მიმართული, უკანდებადი ბლოკზე დაფუძნებული მონაცემთა სტრუქტურა, სადაც თითოეული ელემენტი შენახულია თანმიმდევრულად მეხსიერებაში. მას აქვს ფიქსირებული ზომა და საშუალებას იძლევა სწრაფი (constant time) წვდომა ნებისმიერ ინდექსზე, რადგან მისამართი იანგარიშება ინდექსით. ამით უზრუნველყოფს მაღალი مقperfformance და ზუსტი მიდგომა მონაცემებზე.

Linked List ემყარება "წვეტებს", სადაც თითოეულ ელემენტს აქვს ორი ნაწილი: მონაცემი და ბმული (პოინტერი) შემდეგ ელემენტზე. მისი ობიექტია დინამიური ზომა, რაც ნიშნავს, რომ შესაძლებელია ახალი ელემენტების დამატება ან წაშლა ნებისმიერ პოზიციაზე სწრაფად, _O(1)_ დროში, თუ გვაქვს წვდომა შესაბამის წერტილზე. ძირითადი შეზღუდვა არის ის, რომ ნულიდან წვდომისთვის საჭიროა მთლიანი სიაში გავლა (O(n)).

ამ ორი სტრუქტურის შედარება საინტერესოა: თუ გჭენდეს სელექტიური წვდომა, გამოიყენე Array; თუ ხშირი ჩასმა ან წაშლა ხდება სიის შიგნით, Linked List უკეთესი მოგვარებაა. ასევე, Memory locality–ს მხრივ, Array-ს აქვს უკეთესი cache performance, ხოლო Linked List იწვევს მეტ fragmentation–ს.

Linked List–ის სხვადასხვა სახეობებია: singly, doubly, circular და ორი მიმართულების variant–ები. თითოეულ მათგანს აქვს გამოყენების კონკრეტული სცენარები: მაგალითად, doubly list უკეთესია უკან მიმართულებით სეირნისთვის, circular list შექმნილია ციკლური მიდგომებისთვის.

მნიშვნელოვანია იცოდეთ ალგორითმების კომპლექსურობაც: წვდომა კონკრეტულ ელემენტზე არის O(1) Arrays–ში, მაგრამ O(n) Linked List–ში. ჩასმა დასაწყისში ან ბოლოს Linked List–ში არის O(1), ხოლო Array-ში ხშირი შრიфта ხარჯავს O(n) დროს. ამ ფაქტორების ცოდნა მნიშვნელოვანია, თუ გსურს შექმნა ეფექტური და ოპტიმიზებული პროგრამები.

ამ სტრუქტურებზე მუშაობა ხელს უწყობს მონაცემთა სტრუქტურებისა და ალგორითმების უკეთ გაგებაში, ასევე გეხმარებათ შესაბამისი გადაწყვეტილების მიღებაში პროექტებში — მაგალითად, თამაშების, კრიპტოგრაფიის ან დინამიური UI–ის განვითარებაში.`,
      },
      "stack-and-queue": {
        title: "Stack და Queue",
        description: "მონაცემების მართვა წესრიგის მიხედვით.",
        details:
          "Stack (LIFO) და Queue (FIFO) სტრუქტურები გამოიყენება უამრავ ალგორითმში.",
        resource: "/roadmap/algorithms-data-structures/stack-and-queue/",
        category: "fundamentals",
        estimatedTime: "2 დღე",
        youtubeSrc: "https://www.youtube.com/embed/OS2eE7C1InM",
        bigDescription: `Stack და Queue არიან მონაცემთა სტრუქტურები, რომლებიც გამოიყენება ელემენტების მართვისთვის კონკრეტული წესრიგით.

Stack მუშაობს პრინციპით LIFO — Last In, First Out. ეს ნიშნავს, რომ ბოლოს შეყვანილი ელემენტი გამოაგდება პირველ რიგში. სტეკს აქვს ორი ძირითადი ოპერაცია: push (ელემენტის დამატება ზედა ნაწილზე) და pop (ელემენტისთვის წვდომა და მისი ამოღება). სტეკი გამოიყენება ფუნქციების რექურსიის მართვისას, ბრაუზერის ისტორიის შესანარჩუნებლად, და წილად შესძლებლობის გასანაწილებლად.

Queue ფუნქციონირებს პრინციპით FIFO — First In, First Out. ეს ნიშნავს, რომ პირველ ენტერირებულ ელემენტს ექნება წვდომა პირველ რიგში. Queue-ს აქვს enqueue (დამატება ბოლო ნაწილზე) და dequeue (ამოღება ეროვნული მხრიდან). მას იყენებენ პრინციპში სამუშაოების რიგის მართვისთვის, BFS ალგორითმისთვის და პრინტ-გვერდების Queue სისტემებში.

Stack-ს ტექნიკურად შესაძლოა ჰქონდეს დამატებითი ოპერაციები, როგორიცაა peek (ზედა ელემენტის შემოწმება გარეშე ამოღებისა). Queue-შიც არსებობს ვარიანტები, როგორებიცაა Priority Queue, Deque (double-ended queue), Circular Queue და Blocking Queue. თითოეული მათგანი მიმართულია კონკრეტულ საჭიროებებს — მაგალითად Priority Queue უმეტესი ხდება ელემენტების მოწესრიგებას საჭიროების მიხედვით.

შეადარეთ სტეკი და ქიუ — თუ გინდა უკან მიმართულებით გადაადგილება და რექურსია — გამოიყენე სტეკი. თუ გინდა რიგში მომსახურება ან შეტყობინებების დამუშავება — Queue უკეთესია. ასევე იხსნება მნიშვნელობა ეფექტურობისთვის — ჭკვიანად გამოყენებული მონაცემთა სტრუქტურა ზემოქმედებს შესრულებაზე, მეხსიერების მოხმარებაზე და კოდის სიხსნაზე.

ამ სტრუქტურებზე დაფუძნებული ცოდნა აუცილებელია ალგორითმების დიზაინისთვის, მონაცემთა მართვისთვის და სისტემების ოპტიმალურად ფუნქციონირებისთვის. `,
      },
      "searching-and-sorting": {
        title: "ძებნა და სორტირება",
        description: "გაიცანი ეფექტური ძებნისა და სორტირების ალგორითმები.",
        details:
          "Binary Search, Bubble Sort, Merge Sort და მათი დროითი კომპლექსურობა.",
        resource: "/roadmap/algorithms-data-structures/searching-and-sorting/",
        category: "frameworks",
        estimatedTime: "2-4 დღე",
        youtubeSrc: "https://www.youtube.com/embed/EAU9Y3JHHgk",
        bigDescription: `ძებნის და სორტირების ალგორითმები წარმოადგენს ინფორმაციის მოძიებისა და ორგანიზების ერთ-ერთ ყველაზე მნიშვნელოვან კონცეფციას პროგრამირების და მონაცემთა სტრუქტურებში.

ძებნის ალგორითმებიდან ყველაზე გავრცელებულია ბინარული ძებნა (Binary Search). ეს მეთოდი მუშაობს გამართული ან დაშვებული რიგის ზემოთ და ბოლო სამ ორ ნახევარზე დაყოფით. სწრაფი შედეგისთვის O(log n) დროით, მას შეუძლია მოძებნოს ელემენტი დიდი ზომის მასივში ან სიაში.

სორტირების ალგორითმიდან პირველი მაგალითია Bubble Sort — მარტივი, მაგრამ ნაკლებსი ეფექტური მეთოდი, რომელიც აცვივებს ყველაფერს წყვილებად და ცვლის მათი პოზიციას სანამ სრულად არ იქნება დალაგებული. დროითი კომპლექსურობა არის O(n^2), რაც აცხადებს რომ დიდი მონაცემთა რაოდენობის შემთხვევაში არ არის ეფექტური.

Merge Sort არის უფრო მაღალი დონის ალგორითმი, რომელიც იყენებს “დყენება და გაერთიანება” სტრატეგიას. მას აქვს O(n log n) დროითი და O(n) დამატებითი სივრცის კომპლექსურობა. იგი ეფექტურად იყენებს recurisive პრინციპებს დიდი მასივების დალაგებისთვის.

უფრო თანამედროვე ალგორითმებია Quick Sort, რომელსაც საშუალოდ აქვს O(n log n) შესრულება, მაგრამ უარეს შემთხვევაში შესაძლოა ჰქონდეს O(n^2). იგი იყენებს pivot-ის დაყენებას ელემენტების გასაწყობად და დამოუკიდებლად გაყოფას ორ ქვეკონტექსტში.

სორტირების ალგორითმების შეფასება ხდება დროითი (time complexity) და სივრცითი (space complexity) კუთხით. ვაღიაროთ, რომ O(n log n) არის სივრცობრივი ეფექტურობის ზღვარი, ხოლო O(n^2) მეთოდები გამოიყენება მხოლოდ გაუმჯობესებისთვის ან წვრილ მონაცემთა კორტებზე.

ეს ალგორითმები გამოიყენება ისეთი აპქეიკაციებისათვის, როგორიცაა მონაცემთა ბაზები, UI ელემენტები, real-time სერვისები, ანალიტიკური პლატფორმები და სხვა. მათი მკაფიოდ გაგება ხელს უწყობს იმპლემენტაციის ოპტიმიზაციას, სწორი მონაცემთა სტრუქტურების არჩევას და ეფექტური პროგრამებისა და სისტემების შექმნას.`,
      },
    },
  },
  databases: {
    title: "მონაცემთა ბაზები",
    description: "ისწავლე მონაცემების შენახვა, მართვა და მანიპულაცია",
    icon: Globe,
    color: "bg-teal-500",
    roadmap: {
      "database-fundamentals": {
        // Added slug
        title: "მონაცემთა ბაზის საფუძვლები",
        description: "გაიგე რას ნიშნავს მონაცემთა ბაზა და როგორ მუშაობს.",
        details: "მონაცემთა ტიპები, სქემა და რელაციური სტრუქტურა.",
        resource: "/roadmap/databases/database-fundamentals/",
        category: "fundamentals",
        estimatedTime: "1-2 დღე",
        youtubeSrc: "https://www.youtube.com/embed/mhsp1SSiugk",
        bigDescription: `მონაცემთა ბაზები (database) წარმოადგენს სისტემას, სადაც ინფორმაციის სტრუქტურიზება ხდება გარკვეული წესებისა და რელაციური ანარიცხვების საფუძველზე. მათი მიზანია ინფორმაციის ორგანიზება ისე, რომ მისი შენახვა, წვდომა და მართვა იყოს ეფექტური და უსაფრთხო. ბაზის ძირითადი ელემენტები მოიცავს ცხრილებს (tables), ჩანაწერებს (records), ველებს (fields) და იდენტიფიკატორებს (keys). საზედამხედველოდ, Primary Key–ი არის უნიკალური ციფრი, რომელიც განსაზღვრავს ჩანაწერს ცხრილში, ხოლო Foreign Key–ი მოწოდებული ცხრილის იმოვნება სხვა ცხრილზე კავშირის შესაქმნელად.

რელაციური მონაცემთა ბაზა (RDBMS) ეფუძნება ცხრილურ სტრუქტურას და SQL ენას. შედეგები მიიღება CRUD ოპერაციების საშუალებით – CREATE, READ, UPDATE და DELETE. სქემები განსაზღვრავს, თუ რამდენი ევო ჰყავს ცხრილს და როგორ იშლება კავშირები მათ შორის. წინასწარი უნარებია გასაგები მონაცემთა ტიპები (მაგალითად integer, varchar, date), რომლებიც უზრუნველყოფს დონისა და კონსისტენტურობის კონტროლს.

მონაცემთა ნორმალიზაცია მეთოდია, რომელიც აუმჯობესებს ბაზის სტრუქტურას და ამცირებს დუბლიკაციას. ნორმალიზაციის დონეები (1NF, 2NF, 3NF…) განსაზღვრავს კონკრეტულ ელემენტებს, როგორ უნდა გაიყოფოს ცხრილები, რათა მონაცემი იყოს ერგონომიული და მარტივად მართვადი. ეს ასევე ეხმარება შედარებული შესრულების დემონსტრაციას.

SQL სქრიპტის მაგალითის საშუალებით:
SELECT name, age FROM users WHERE active = true ORDER BY created_at DESC;
INSERT INTO products (name, price) VALUES ('Item', 9.99);
UPDATE orders SET status = 'shipped' WHERE id = 123;
DELETE FROM sessions WHERE expires < NOW();

ბაზები იყოფა რელაციურ სისტემებად (მაგ., MySQL, PostgreSQL) და NoSQL სისტემებად (მაგ., MongoDB, Redis). პირველი იდეალური არიან სტრუქტურიზებულ მონაცემებზე, მეორე — დიდი მოცულობის, დინამიური ან არასახელმძღვანელო მონაცემებისთვის.

მონაცემთა ბაზის შენახვის მოდელები მოიცავს ტერმინებს როგორიცაა ACID (Atomicity, Consistency, Isolation, Durability), რომლებიც უზრუნველყოფს ბაზის ოპერაციების სანდოობას და კონსისტენტურობას. ასევე გამოყენებადია საკვანძო მივაქცევა როგორც CAP თეორემის კონტექსტში — Consistency, Availability, Partition tolerance.

მონაცემთა ბაზების სწავლა საჭიროა იმისთვის, რომ შეძლოთ შექმნათ გაუმჯობესებული, სწრაფად გამოყენებადი და გამძლე სისტემები. თუ გსურთ გააგრძელოთ კარიერა DevOps–ში, ბექენდ დეველოპმენტში ან მონაცემთა მეცნიერებაში, მათი ცოდნა არის ფუნდამენტი მთლიან ეკოსისტემაში.`,
      },
      sql: {
        title: "SQL",
        description: "ისწავლე მონაცემებზე წვდომის ენა SQL.",
        details:
          "SELECT, INSERT, UPDATE, DELETE — ძირითადი ოპერაციები რელაციურ ბაზებში.",
        resource: "/roadmap/databases/sql/",
        category: "tools",
        estimatedTime: "2-4 დღე",
        youtubeSrc: "https://www.youtube.com/embed/HXV3zeQKqGY",
        bigDescription: `SQL (Structured Query Language) არის სტანდარტული ენა, რომელიც გამოიყენება რელაციურ მონაცემთა ბაზებთან მუშაობისთვის. SQL-ის დახმარებით შეგიძლიათ შეკვეთოთ მონაცემები, ჩაწეროთ ახალი ჩანაწერები, განაახლოთ არსებული მონაცემები და წაშალოთ საჭირო ინფორმაციით ჩანაწერები. ძირითადი ოპერაციებია SELECT (მონაცემების წაკითხვა), INSERT (დამატება), UPDATE (განახლება) და DELETE (წაშლა).

SELECT საკითხავია ყველაზე ხშირად გამოყენებული — მისი სინტაქსი არის მარტივი და მოქნილი. მაგალითად:
SELECT name, age FROM users WHERE active = true ORDER BY created_at DESC;
ეს შეკვეთვა გამოიტანს ყველა აქტიურ მომხმარებელს და დაალაგებს მათ რეგისტრაციის დროის შესაბამისად.

INSERT-ის გამოყენებით შესაძლებელია ჩანაწერების დამატება:
INSERT INTO products (name, price) VALUES ('Item', 19.99);

UPDATE:
UPDATE orders SET status = 'shipped' WHERE id = 123;

DELETE:
DELETE FROM sessions WHERE expires < NOW();

SQL ასევე ამატებს ფუნქციებს, როგორიცაა ჯგუფური ოპერაციები (GROUP BY), აგრეგატური ფუნქციები (SUM, COUNT, AVG), ტექნიკური ჩანაწერები და შეზღუდვები (JOIN, FOREIGN KEY). ამ ელემენტებით ვახდენთ მონაცემთა დაკავშირებას, ფორმატირებას და კომპლექსური ანალიზის განხორციელებას.

მნიშვნელოვანია იცოდეთ ტრანზაქციები (BEGIN, COMMIT, ROLLBACK), რომლებიც უზრუნველყოფს ოპერაციების დასასრულს ან გადახრჩობას შეცდომის შემთხვევაში. ეს არის მონაცემთა უსაფრთხოების და კონსისტენტურობის საფუძველი.

SQL-ში ასევე გამოიყენება ინდექსები, რომლებიც აბამენ შესრულებას SELECT ოპერაციების დროს, თუმცა საჭიროებს დამატებით რესურსს ჩანაწერის დროს. ამიტომ მნიშვნელოვანია სწორი ინდექსების გამოყენება და ბაზის ოპტიმიზაცია.

დღესდღეობით, SQL ენის გამოყენება აუცილებელია ნებისმიერი ბექენდ‑დეველოპერისთვის, პირადი ან სერვერთან მომუშავე პროცესში. მისი ცოდნა სასიცოცხლოა, როცა ვემუშაობთ relational DBMS-ებთან, როგორიცაა MySQL, PostgreSQL, SQLite და Oracle.

SQL-ს სწავლა იწყება მარტივი შეკვეთით და თანდათან გადაიზრდება უფრო კომპლექსურ თემებზე — როგორიცაა ქვეკვეთები (subqueries), view-ები, stored procedures და performance tuning. რაც უფრო უკეთ გაიგებთ SQL-ის პრინციპებს, მით უფრო დღესაკალურ და ოპტიმიზებულ მონაცემთა მართვაში იქნებით წამყვანი.`,
      },
      "indexes-and-normalization": {
        title: "ინდექსები და ნორმალიზაცია",
        description: "გაუმჯობესე მონაცემთა ბაზის ეფექტურობა.",
        details:
          "ნორმალიზაციის დონეები და ინდექსების სტრატეგიები მონაცემების სწრაფად მოსაძებნად.",
        resource: "/roadmap/databases/indexes-and-normalization/", // This resource points to NoSQL, consider if intentional
        category: "tools",
        estimatedTime: "2 დღე",
        youtubeSrc: "https://www.youtube.com/embed/9Pzj7Aj25lw",
        bigDescription: `ინდექსები და ნორმალიზაცია წარმოადგენს ორი ისეთ კონცეფციას, რომლებიც მნიშვნელოვნად ავითარებენ მონაცემთა ბაზის შესრულებას, სტაბილურობას და მართვადობას.

ინდექსი არის მონაცემთა სტრუქტურა, რომელიც უზრუნველყოფს სწრაფ წვდომას ჩანაწერებზე. იგი მსგავსია წიგნის ან ბიბლიოთეკის მრიცხველ რეჟიმს, სადაც შენიშვნით შეგიძლია სწრაფად იპოვნო საჭირო გვერდი ან წიგნი. SQL ბაზებში, ინდექსი ზოგჯერ გამოიყენება სტრუქტურებად B‑tree ან Hash–ზე დაფუძნებული მონაცემის ორგანიზებისთვის. მაგალითად:
CREATE INDEX idx_users_email ON users(email);
ეს ბრძანება ქმნის ინდექსს ელ-ფოსტის სვეტზე, რაც აჩქარებს QR ელემენტის წამოღებას. ინდექსის არსებობა ზრდის SELECT ოპერაციების პროდუქტიულობას, თუმცა დამატებით ზრდის მონაცემთა ჩაწერის დროს და რესურსთა მოხმარებაში.

ნორმალიზაცია არის ტექნიკური მიდგომა, რომლის მიზანია მონაცემთა გამეორების მინიმიზირება და მონაცემთა მთლიანობის უზრუნველყოფა. არსებობს რამდენიმე დონე:
1NF: თითოეული სვეტი შეიცავს მხოლოდ ერთი მნიშვნელობას და ჩანაწერები უნიკალურია।
2NF: გათვალისწინებული უნდა იყოს ყველა სვეტისთვის სრულად დამოკიდებულება პრაიმარში.
3NF: ყოველ არასაკვირველ სვეტს აქვს მხოლოდ პრაიმარში დამოკიდებულება и არა სხვა სვეტზე. ეს დონეები ხელს უწყობს მონაცემთა სტრუქტურის გამარტივებას და ატრიბუტების სახელების კონსისტენტურობის დაცვას.

პირობითი მაგალითი: 
თუ ცხრილში გაქვს გეოგრაფიული მონაცემები (ქალაქი, პოლიტიკა), მაშინ გამოვყოფ ცხრილების:
Users(id, name, city_id);
Cities(id, name);
ეს გზით მონაცემები არ გაიმეორებს და მონაცემთა ცვლილებები უფრო მარტივად ხდება.

გრძელვადიან პერსპექტივაში, ნორმალიზაცია აუმჯობესებს მონაცემთა მართვის ხარისხს და შემცირებულია სიჩქარის დაბალი ეფექტურობა მცირე–მედია ოპერაციებისას. თუმცა, ზოგჯერ გამოიყენება დენორმალიზაცია (მონაცემთა წინასწარი გაერთიანებები), რაც აჩქარებს SELECT ოპერაციებს მძიმე წვეთებზე, თუმცა ზრდის ჩაწერის სირთულეს.

ინდექსებისა და ნორმალიზაციის სწორი კომბინაცია ვალდებულია მაღალხარისხიან და სწრაფ SQL-ბაზას. ისინი უზრუნველყოფენ ოპტიმიზაციას, მონაცემთა კონტროლს და წვდომის ეფექტურობას, რაც კრიტიკულია ფართო მასშტაბიანი სისტემებისთვის და პოპულარულიუშავებისთვის.`,
      },
      nosql: {
        title: "NoSQL",
        description: "გაიგე როდის და რატომ გამოიყენება NoSQL (მაგ. MongoDB).",
        details: "დოკუმენტური, Key-Value, Column Store და Graph ტიპის ბაზები.",
        resource: "/roadmap/databases/nosql/",
        category: "tools",
        estimatedTime: "2-3 დღე",
        youtubeSrc: "https://www.youtube.com/embed/Puc2EjkdycU",
        bigDescription: `NoSQL წარმოადგენს დანარჩენი ტიპის მონაცემთა ბაზებს, რომლებიც განსხვავდებიან კლასიკური რელაციური მოდელისგან და ეფუძნებიან სხვადასხვა სქემას და გამოყენების სცენარს. ისინი განსაკუთრებით ეფექტურნი არიან დიდი მოცულობის, დინამიური და არასტრიქტული მონაცემებისთვის.

NoSQL სისტემა იყოფა რამდენიმე ტიპად:
- დოკუმენტური ბაზები (მაგალითად MongoDB): ინახავს JSON-ის მსგავსი დოკუმენტებს და ნებადართულია შიდა სტრუქტურიანათ დამოკიდებულობა.
- Key‑Value სტორები (Redis, DynamoDB): ინახავს ჩანაწერს გასაღებად და მნიშვნელობად, იდეალურია სწრაფ დაწერასა და წაკითხვაზე.
- Column Store (Cassandra, HBase): განკუთვნილია დიდი მონაცემებისთვის, რომლებიც ორგანიზებულია სვეტების მიხედვით.
- Graph ბაზები (Neo4j): ხელს უწყობს საგანთა სისტემური კავშირების და გრაფების მოდელირებას, როგორიცაა სოციალური ქსელები.

MongoDB არის ერთ-ერთი ყველაზე პოპულარული NoSQL დოკუმენტური ბაზა. იგი საშუალებას გვაძლევს შევქმნათ სტრუქტურულად თავისუფალი დოკუმენტები და ჩავატაროთ რთული შეკვეთები JSON Queries-ის მეშვეობით. NoSQL ბაზები არ საჭიროებენ წინასწარ სქემის განსაზღვრას, რამაც გაადვილა განვითარება და მონაცემის ევოლუცია პროექტის პროცესში.

NoSQL არ იცავს ტრადიციული SQL ტრამზაქციების ყველა ელემენტს, თუმცა ბევრ შემთხვევაში შეუძლია უზრუნველყოფა კონსისტენტურობის, ხელმისაწვდომობისა და ნაწილობრივი ინტაქტურობის (CAP თეორემა). მაგალითად, Cassandra ვაჭირდება გარკვეულ დაამყარებულ თვისებებს სწრაფობისთვის.

NoSQL-ის გამოყენების მაგალითებია რეალურ დროს ანალიტიკა, ხასიათები და სესიის მონაცემები, IoT მოწყობილობების მონაცემთა ნაკადი, და დიდი მასშტაბის ვებაპლიკაციები. მათი სწორი გამოყენება მოითხოვს განზომილების დაგეგმას, shards-ებისა და replicas-ების მართვას, მოდელის ოპტიმიზაციას და შესაბამისი ინდექსების გამოყენებას.

NoSQL სისტემა პლატფორმაა დიდი მონაცემებისთვის, სწრაფ აპრობაციებისთვის და მოცემულობებზე, სადაც მონაცემთა სტრუქტურა შეიძლება დროთა განმავლობაში შეიცვალოს. მისი სწავლა აუმჯობესებს შენს შესაძლებლობებს თანამედროვე distributed სისტემებში მუშაობისა და სწრაფი განვითარების მიდგომების შესაქმნელად.`,
      },
    },
  },
  "mobile-development": {
    title: "მობაილ დეველოპმენტი",
    description:
      "ისწავლე როგორ შეიქმნას მძლავრი აპლიკაციები iOS და Android-სთვის",
    icon: Globe,
    color: "bg-emerald-500",
    roadmap: {
      "mobile-platform-introduction": {
        // Added slug
        title: "მობილური პლატფორმების გაცნობა",
        description: "გაიგე განსხვავება iOS და Android-ს შორის.",
        details: "სისტემის არქიტექტურა, Store წესები და ძირითადი კომპონენტები.",
        resource: "/roadmap/mobile-development/mobile-platform-introduction/",
        category: "fundamentals",
        estimatedTime: "1 დღე",
        youtubeSrc: "https://www.youtube.com/embed/fpX5kIONdKA",
        bigDescription: `მობილური პლატფორმების გაცნობა წარმოადგენს პირველ ნაბიჯს მობილური აპების განვითარების პროცესში. ინდუსტრიაში ორი ძირითადი ოპერაციული სისტემა დომინირებს: Android და iOS. Android არის ღია წყარო, Google-ის მიერ विकसितებული, რომელიც გამოიყენება სხვადასხვა მწარმოებლების მოწყობილობებზე. iOS არის Apple-ის ეკოსისტემაში ჩარჩენილი, დახურული და tightly integrated პლატფორმა iPhone და iPad მოწყობილობებისთვის.

იტიაპისეულ დონეზე მნიშვნელოვანია არქიტექტურული განსხვავება: Android–ზე მუშაობს ბიბლიოთეკები Java/Kotlin–ზე დაფუძნებული, Dalvik/ART runtime-ით და დინამიკის გადამუშავებით გადააჩნია APK პაკეტებში. iOS აპები წერილდება Swift-ით ან Objective-C–ით და განაწილებულია IPA–ში, რომლებიც tightly integrate-ებულია CoreServices და UIKit/SwiftUI–ში.

Store–ის წესები განსხვავებულია: Google Play ორიენტირებულია ღია ფორმატზე და უფრო მოქნილი პოლიტიკით, რაც საშუალებას აძლევს დეველოპერებს გამოაქვეყნონ აპები სწრაფად, თუმცა დაცვას სჭირდება Google Play Protect. App Store აცხადებს მკაცრ გატარებულ შემოწმებას, სადაც აპები გადიან review პროცესს, რაც უზრუნველყოფს მაღალი ხარისხის და უსაფრთხოების სტანდარტს.

მობილურ აპებში მნიშვნელოვანია Device fragmentation, ანუ მოწყობილობების მრავალფეროვნება — სხვადასხვა ეკრანის ზომები, პროცესორები და ოპერატიული მეხსიერების მოცულობა. Android–ზე მოწყობილობების სპექტრი დიდია, რაც ნიშნავს კოდის მოქნილობას და multiple form factor–ზე ტესტირების აუცილებლობას. iOS პარაგმენტულია ნაკლებად, მაგრამ აუცილებელია iOS ვერსიებზე დოკუმენტაცია და backward compatibility.

UI კომპონენტები ასევე განსხვავდება: Android–ზე Material Design–ის მხარს უწევს და UI მაღალი კონფიგურირებადობით, ხოლო iOS–ზე UIKit/SwiftUI ეფუძნება Apple–ის Human Interface Guidelines. დეველოპერებს სასურველია იცოდნენ platform-specific UI behavior–ები და gesture–ები, რათა მომხმარებლის გამოცდილება იყოს intuative და Native look & feel.

მობილური აპების მუშაობა იყოფა არქიტექტურულ ასპექტებში: frontend–ის და backend–ის ურთიერთქმედება REST/GraphQL API–ზე, მონაცემთა მართვა ერთჯერადი დროებით appაფილეებზე, ასევე persistent cache–ზე (SQLite ან Core Data / Room). უსაფრთხოებისთვის გამოიყენება Android–ზე permissions და iOS–ზე entitlement–ები, რაც რეგულაციურად იცვლება და მოითხოვს მონაცემთა დაცვის სრულ შესაბამისობას.

მობილური აპების პლატფორმებთან მუშაობის ცოდნა აუცილებელია ნებისმიერი დეველოპერისთვის, ვინც იწყებს career-ს mobile development-ში. ეს საფუძველი გაძლევთ სწორად აირჩიოთ ტექნოლოგია, გააცნობიეროთ შეზღუდვები და შექმნათ მაღალი ხარისხის, performant აპლიკაციები.`,
      },
      flutter: {
        title: "Flutter",
        description: "დაწერე მობილური აპები Dart ენით.",
        details:
          "Flutter-ს გამოყენებით ერთ აპში შეგიძლია შექმნა ორივე პლატფორმისთვის თავსებადი აპლიკაცია.",
        resource: "/roadmap/mobile-development/flutter/",
        category: "frameworks",
        estimatedTime: "1-2 კვირა",
        youtubeSrc: "https://www.youtube.com/embed/HQ_ytw58tC4",
        bigDescription: `Flutter არის Google-ის მიერ მოწოდებული UI toolkit, რომელიც საშუალებას გაძლევს შექმნა მაღალი ხარისხის, natively compiled აპლიკაციები სხვადასხვა პლატფორმებისთვის — Android, iOS, web და desktop. Flutter მუშაობს Dart ენის გამოყენებით და ფოკუსირდება სწრაფ და ინფორმატიულ UI–ზე.

ძირითადი კონცეპტებია — Widgets. ყველა UI ელემენტს აქვს საკუთარი widget–ი: Text, Button, Image, ListView და ა.შ. Flutter უზრუნველყოფს თანამედროვე ডিজაინის მხარდაჭერას Material Design და Cupertino სტილებში. მისი მთავარი უპირატესობა არის hot reload ფუნქციონალი, რაც შეამცირებს ვითარებას realtime–ში — კოდის ცვლილების ჩარევა UI–ზე სწრაფ შედეგს ბრუნდება.

Flutter არქიტექტურით იყოფა layersებად:  
UI layer (Widgets), Rendering layer (Element tree), დასასრულს Framework layer (gesture detection, animation loop). ეს განაწილება ეხმარება maintainability–სა და scalable აპების შექმნაში.

პროექტების შექმნა იწყება Dart-ის ძირითადი ელემენტებით: variables, functions, classes, Futures და Streams. ხშირად იყენებენ state management libraries–ს, როგორიცაა Provider, Bloc ან Riverpod — ეს ეხმარება პროექტების დიდი მასშტაბით სტრუქტურირებას. მისთვის გამოიყენება კოდი დასაწერად ან JSON–ის გადაჯგუფებისთვის http ან dio პაკეტებით.

Flutter-ს აქვს ძლიერი ეკოსისტემა: plugins pub.dev–ზე, სადაც არის თანამედროვე ინსტრუმენტები — მაგალითად firebase_auth, cloud_firestore, image_picker, camera და სხვ. მათი დახმარებით შესაძლებელია აპებს მიენიჭოს პოზიტიური ფუნქციონალები: ავტორიზაცია, მონაცემთა შენახვა, რესტ API და ლოკალური ატრიბუტები.

პროექტის განვითარების პროცესში ციცოებია UI–ს ტესტები, unit და widget ტესტები — ეს უზრუნველყოფს კოდის ხარისხსა და საიმედოობას. გარდა ამისა, გამოიყენება CI/CD გაფართოებები — CodeMagic, GitHub Actions ან GitLab Pipelines — რათა აპი ავტომატურად შეამოწმოს და შეასრულოს build.

Flutter ასევე იძლევა performance profiling–ს Android Studio–ში ან DevTools–ში, რაც ეხმარება memory და CPU კვლევას და აპის ოპტიმიზაციისთვის. საბოლოოდ, გამოცხადდება აპების გამოშვება Android–ზე .apk/.aab ფორმატში და iOS–ზე IPA–ში, შემდეგ კი მათი განთავსება შესაბამისი App Store–ში.

Flutter პროექტი საუკეთესოა მაშინ, როცა გინდა:
- მაღალი ხარისხი და თანმიმდევრული UI მრავალ პლატფორმაზე,
- პროდუქტიულად წვდომა Native API–ზე,
- სწრაფი iteration განვითარების პროცესში.

თავდაპირველი გაცნობის შემდეგ, რეკომენდებულია მცირე პროექტების, UI დედატების და Reusable Components შექმნა, მერე კი ბუნებრივია მიგრირება უფრო რთულ სისტემებზე და არქიტექტურულ მიდგომებზე. Flutter არის ძლიერი იარაღი მოდელ-ორიენტირებულ UI–ზე ტრადიციული აპების განვითარების გზაზე.`,
      },
      "react-native": {
        title: "React Native",
        description: "მობილური აპების შექმნა React-ის ცოდნის საფუძველზე.",
        details: "Reusable კომპონენტები, Expo, Navigation და API call-ები.",
        resource: "/roadmap/mobile-development/react-native/",
        category: "frameworks",
        estimatedTime: "1-2 კვირა",
        youtubeSrc: "https://www.youtube.com/embed/0-S5a0eXPoc",
        bigDescription: `React Native არის Facebook–ის მიერ შექმნილი cross-platform framework, რომლის დახმარებით შესაძლებელია ნატიური (native-like) მობილური აპების განვითარება JavaScript და React კომპონენტების გამოყენებით. ეს საშუალებას გაძლევს ერთ კოდის ბაზაზე შექმნა iOS და Android აპლიკაციების UI, ფუნქციები და ლოგიკა.

React Native იყენებს React-ის ძირითადი პრინციპებს: თვალსაჩინოები კომპონენტები (functional components) და state–მართვა (React Hooks), როგორიცაა useState და useEffect. კომპონენტები მზად არიან მდგრად ფუნქციონირებისთვის და UI ელემენტები იყიდება React Native–ის საფუძვლით: View, Text, Image, ScrollView, FlatList და Button.

პროექტის დასაწყისში ხშირად გამოიყენება Expo — ეს არის დამატებითი toolchain, რომელიც აძლიერებს app-ის სწრაფ გაშვას, build–ებისა და სკრიპტის ოპტიმიზაციას, ხოლო production build–ისთვის შესაძლებელია გადართვა „bare workflow“-ზე, სადაც დეველოპერი იღებს სრულ კონტროლს native მოდულებზე.

React Navigation ან React Native Navigation იხმარება app-ის შიგნით ეკრანებს შორის გადასაცემად და საჭირო ფუნქციების დამატებისთვის — deep linking, drawer–ები ან bottom tabs. კომპონენტებს შესაძლოა ჰქონდეთ props და state, ხოლო შიდა კავშირი REST ან GraphQL API–ზე ეფექტურად ენაცვლება fetch ან axios პაკეტების მეშვეობით.

საქმეიისას მნიშვნელოვანია მხედველობა memory leak–ებისა და performance issues–ის მართვისთვის — მაგალითად FlatList–ის გამოყენების დროს ვიტამინე რენდერის ოპტიმიზაციაზე, keyExtractor ფუნქციაზე და virtualization ტაქტიკაზე.

React Native-ის პროექტებიდან მნიშვნელოვანი რამ არის Native Modules და Native UI Components — საჭიროების შემთხვევაში შეგიძლიათ დაამატოთ Java/Kotlin ან Objective-C/Swift ნაწილები და უკავშირდეთ JavaScript–ს NativeModules–ის მეშვეობით.

აპლიკაციის ტრენინგის შემდეგ, QA პროცესში ჩართეთ unit და e2e (სიმულირებული აპლიკაციები) ტესტები — Jest და React Native Testing Library, Detox ან Appium. ასევე, continuous integration–ისთვის GitHub Actions ან Bitrise–ს აკავშირებთ build–სა და test–ს ავტომატურად.

build–ის დასრულების შემდეგ შესაძლებელია აპლიკაციის გამოქვეყნება App Store და Google Play–ზე — ამ პროცესში გამოიყენება Android App Bundle (.aab) და iOS .ipa ფორმატები, provisioning profiles და certificates.

React Native არის ძლიერი არჩევანი, როცა გვსურს სწრაფი განვითარება, მრავალპლატფორმა გამოსახულება და JavaScript–თან სიახლოვე. სავარჯიშოდ რეკომენდებულია: ToDo აპის ან პრაზიუმის შექმნა, შემდეგ უფრო რთული პროექტები — როგორიცაა Chat, Map integration ან Offline persistence. ეს გზა გაძლევთ ფუნდამენტურ უნარებს cross-platform დეველოპმენტის სფეროში.`,
      },
      "deploy-and-testing": {
        title: "დეპლოი და ტესტირება",
        description: "აპის რეალურ მოწყობილობაზე გამოცდა და ატვირთვა Store-ში.",
        details: "Testing, Crashlytics, Play Store და App Store-ის წესები.",
        resource: "/roadmap/mobile-development/deploy-and-testing/",
        category: "tools",
        estimatedTime: "2-4 დღე",
        youtubeSrc: "https://www.youtube.com/embed/PK2VlfcQ7xk",
        bigDescription: `Deploy და Testing წარმოადგენს მობილური აპლიკაციების განვითარების მნიშვნელოვან ეტაპს, სადაც ხდება აპის მზადება რეალურ სამყაროში გამოსაცემად.

Deploy არის აპლიკაციის გამოქვეყნების პროცესი, რომელიც მოიცავს build–ის შექმნას production რეჟიმში და მისი ატვირთვას შესაბამისი პლატფორმის Store–ში. Android აპებისთვის გამოიყენება Android App Bundle (.aab) და Google Play Console–ზე ატვირთვა. iOS აპებისთვის — .ipa ფაილი, Xcode–ში App Store Connect–ზე ატვირთვა და Apple–ის Review პროცესის გავლა. პროცესში მნიშვნელოვანია სწორად მორგებული metadata, სიმართლის ლიცენზიები, გვერდის ხატები და screenshot–ები.

Testing პროცესი მოიცავს:
unit ტესტებს (კოდის სწორი მუშაობის შესამოწმებლად), integration UI ტესტებს, end-to-end აღდგენას და რელიზამდე სტაბილურობის დონის შეფასებას. ხშირად იყენებენ Jest, XCTest, Espresso და Detox ან Appium ინსტრუმენტებს.

Crashlytics და სხვა Crash Reporting ინსტრუმენტები (Firebase Crashlytics, Sentry), გამოიყენება მობილური აპების ტესტირების ფაზების ან production–ში შეცდომების მოსაპოვებლად უცნობი აპარატების პირობებში. Crashlytics აგროვებს ინფორმაცია საპრობლემო სიტუაციებზე, stack trace–ზე და მომხმარებლის გარემოზე.

CI/CD–ს გამოყენება (Continuous Integration / Continuous Deployment) ავტომატიზირებულ YAML–ს ან GUI–ს საშუალებით უზრუნველყოფს build–ის შექმნისა და ტესტების შესრულების შემდეგ შესაბამისი ატვირთვის პროცესისთვის. ხშირად გამოიყენებენ GitHub Actions–ს, Bitrise–ს, Codemagic–ს ან CircleCI–ს.

აპლიკაციის გამოქვეყნება იწვევს მკაცრ Store–ების ზედამხედველობას — Apple და Google აკონტრილს უსაფრთხოების, კონფიდენციალური ინფორმაციის მიღების (permissions) და მომხმარებლის გამოცდილებაზე. ამისთვის საჭიროა app privacy–ს ინფორმაციის დამატება, შეკვეთა Google–ის Data Safety Form-ში ან Apple Privacy Manifest-ში.

Deploy და Testing არის არა მხოლოდ ტექნიკური განხორციელება — ეს არის ხარისხის, ხარისხის და საიმედოობის გარანტი. აპის წარმატება ბაზარზე დამოკიდებულია სწორი პროცესით მომზადებასა და მომხმარებელთან first-run გამოცდილებაზე.

თუ გინდა გადავიდეთ სხვა თემებზე ან უფრო მეტ შინაარსზე გავგრძელოთ, სიამოვნებით!`,
      },
    },
  },
};
